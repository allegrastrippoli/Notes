#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass amsart
\use_default_options true
\begin_removed_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_removed_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
ASW
\end_layout

\begin_layout Section
Layers
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Itemize
Un sistema deve essere decomposto.
\end_layout

\begin_layout Itemize
Le diverse parti del sistema devono poter evolvere in modo indipendente.
\end_layout

\begin_layout Itemize
Le qualità da sostenere sono modificabilità, riusabilità e/o portabilità.Non
 bisogna penalizzare altre qualità.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Itemize
Decomponi il sistema in una gerarchia verticale di elementi software, chiamati
 strati.
\end_layout

\begin_layout Itemize
Ciascuno strato ha una responsabilità distinta e ben specifica.
\end_layout

\begin_layout Itemize
Uno strato dipende solo da se stesso o dagli strati inferiori.
\end_layout

\begin_layout Itemize
Fornisci, in ciascuno strato, un’interfaccia che è separata dalla sua implementa
zione – e basa la comunicazione tra strati solo su queste interfacce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-07 at 15.30.14.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
struttura statica della soluzione.
 Cosa rappresenta una freccia? Nell'implementazione di uno strato superiore
 viene chiamata l'interfaccia di uno strato inferiore.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Scenario che mostra comportamento dinamico del pattern
\end_layout

\begin_layout Subsection*
Comunicazione top-down basata su richiesta riposta
\end_layout

\begin_layout Enumerate
Un client effettua una richiesta allo strato più alto N 
\end_layout

\begin_layout Enumerate
In ciascuno strato l'elaborazione di una richiesta può dar luogo via via
 a delle richieste (ed elaborazioni) negli strati inferiori N-1, N-2, ...
 Dunque le richieste scendono tra gli strati.
\end_layout

\begin_layout Enumerate
In ogni strato l'elaborazione di una richiesta può dar luogo ad una risposta.
 Le risposte vengono via via elaborate e restituite agli strati superiori.Le
 risposte risalgono tra gli strati.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-07 at 15.32.56.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
comunicazione top-down
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-07 at 15.42.09.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
client fa una richiesta.
 Tutte le richieste partono da Layer 3 ma non è detto che scendano fino
 a layer 1.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Comunicazione bottom-up basata sulla notifica di eventi
\end_layout

\begin_layout Enumerate
Allo strato più basso arrivano delle notifiche (attenzione: non da parte
 di un client).
 Ogni notifica descrive che si è verificato un certo evento (con i relativi
 dati).
 
\end_layout

\begin_layout Enumerate
L'elaborazione di ciascuna notifica/evento può dar luogo ad ulteriori notifiche
 che vengono trasmesse verso gli strati superiori.
 Le notifiche/ eventi risalgono tra gli strati dove vanno elaborate/ interpretat
e.
\end_layout

\begin_layout Standard
Potrebbe essere utile per garantire che i livelli superiori siano sempre
 informati sullo stato degli strati più bassi e possano prendere decisioni
 appropriate in caso di problemi o errori.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-07 at 15.47.30.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
comunicazione bottom-up
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Discussione
\end_layout

\begin_layout Standard
Ciascuno strato può definire diverse interfacce:
\end_layout

\begin_layout Itemize
Un’interfaccia (fornita) affinché gli strati superiori possano invocare
 le operazioni.
 L'interfaccia fornita è implementata da uno strato più basso.
\end_layout

\begin_layout Itemize
Un’interfaccia (richiesta) per invocare operazioni degli strati inferiori.
 L'interfaccia richiesta è implementata da uno strato più alto.
\end_layout

\begin_layout Itemize
Un’interfaccia (fornita) per notificare eventi agli strati superiori.
\end_layout

\begin_layout Itemize
Un’interfaccia (richiesta) per accettare notifiche di eventi ricevute da
 strati inferiori.
\end_layout

\begin_layout Standard
Nell’architettura a strati, le dipendenze sono dall’alto verso il basso.
\end_layout

\begin_layout Standard
A = alto
\end_layout

\begin_layout Standard
RR = richiesta risposta 
\end_layout

\begin_layout Standard
L = listener
\end_layout

\begin_layout Standard
B = basso
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-07 at 16.32.17.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Le dipendenze sono dall’alto verso il basso se e solo se la freccia che
 attraversa il confine tra gli strati è C
\begin_inset Formula $_{A}$
\end_inset

 
\begin_inset Formula $\rightarrow$
\end_inset

 C
\begin_inset Formula $_{B}$
\end_inset

.
 Nella figura a SX è vero perché C
\begin_inset Formula $_{A}$
\end_inset

 invoca le operazioni grazie l'interfaccia fornita da C
\begin_inset Formula $_{B}$
\end_inset

.Nella figura a DX è vero perché C
\begin_inset Formula $_{A}$
\end_inset

 implementa l'interfaccia richiesta tramite cui C
\begin_inset Formula $_{B}$
\end_inset

 notifica gli eventi.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Figura a SX: componente C
\begin_inset Formula $_{A}$
\end_inset

 invoca le operazioni specificate dall'interfaccia I
\begin_inset Formula $_{RR}$
\end_inset

 che è implementata (fornita) da un componente C
\begin_inset Formula $_{B}$
\end_inset


\end_layout

\begin_layout Itemize
Figura a DX: C
\begin_inset Formula $_{B}$
\end_inset

 notifica eventi ad un componente C
\begin_inset Formula $_{A}$
\end_inset

.
 C
\begin_inset Formula $_{B}$
\end_inset

 è un publisher, C
\begin_inset Formula $_{A}$
\end_inset

 è un subscriber e viene introdotta l'interfaccia (richiesta) I
\begin_inset Formula $_{L}$
\end_inset

 implementata da C
\begin_inset Formula $_{A}$
\end_inset

.
 Quando si verifica un evento, C
\begin_inset Formula $_{B}$
\end_inset

 lo notifica ai propri subscriber mediante I
\begin_inset Formula $_{L}$
\end_inset

.
\end_layout

\begin_layout Subsection*
Come si applica il pattern?
\end_layout

\begin_layout Enumerate
Si definisce un criterio di partizionamento.
 
\end_layout

\begin_layout Enumerate
Si determina il numero di strati, le loro responsabilità i servizi offerti.
\end_layout

\begin_layout Enumerate
Vengono definite le interfacce.
\end_layout

\begin_layout Enumerate
Viene specificato il metodo di comunicazione: es.
 top-down, bottom-up.
\end_layout

\begin_layout Enumerate
Viene progettata strategia per la gestione degli errori.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Layered Architecture di DDD
\end_layout

\begin_layout Standard
Quali sono gli strati:
\end_layout

\begin_layout Itemize

\series bold
Presentation layer
\series default
 – UI o presentazione, mostra informazioni all'utente e interpreta le richieste.
\end_layout

\begin_layout Itemize

\series bold
Application layer
\series default
.
 Rappresenta in modo specifico i casi d'uso di interesse per l'applicazione
 e le operazioni di sistema.
 È responsabile di gestire lo stato delle conversazioni/sessioni con i suoi
 client.Sono possibili due implementazioni principali:
\end_layout

\begin_deeper
\begin_layout Itemize
Opzione 1: un insieme di facade sottili, che delegano lo svolgimento delle
 operazioni di sistema a oggetti opportuni dello strato del dominio.
 
\end_layout

\begin_layout Itemize
Opzione 2: un insieme di classi più spesse che definiscono degli “operation
 script” – che implementano direttamente la logica applicativa, ma delegano
 la logica di dominio allo strato del dominio.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Domain layer
\series default
.
 Rappresenta il modello di dominio, ed in modo generale la logica del dominio
 (che non dipende dai casi d'uso di interesse).Gli oggetti di dominio – liberi
 dalla responsabilità di visualizzarsi, di memorizzarsi e di gestire compiti
 dell’applicazione – sono focalizzati sulla rappresentazione del modello
 di dominio.
\end_layout

\begin_layout Itemize

\series bold
Infrastructure layer 
\series default
– infrastruttura, ad esempio gestisce accesso ai dati.
\end_layout

\begin_layout Subsection*
Decomposizione in strati in DDD
\end_layout

\begin_layout Standard
È necessario scegliere un criterio di decomposizione delle funzionalità.
 
\end_layout

\begin_layout Standard
In generale, questa decomposizione dovrebbe garantire che ciascun gruppo
 di funzionalità sia incapsulato in uno strato e che possa essere sviluppato
 ed evolvere indipendentemente dagli altri gruppi di funzionalità.
\end_layout

\begin_layout Standard
Criteri di decomposizione comuni:
\end_layout

\begin_layout Enumerate
il criterio dell’
\series bold
astrazione
\series default
 può essere applicato nei sistemi che si devono occupare della gestione
 di diversi aspetti, a livelli di astrazione differenti.
 Questo criterio viene spesso utilizzato per motivare una decomposizione
 tecnica in strati come: presentazione, logica applicativa e infrastruttura
 – che sono responsabilità a livelli di astrazione differenti.
\end_layout

\begin_layout Enumerate
il criterio della 
\series bold
granularità
\series default
 può portare a una suddivisione in: uno strato che rappresenta oggetti o
 servizi di business, servizi che vengono usati da un secondo strato, strato
 di processi di business.
\end_layout

\begin_layout Enumerate
il criterio della
\series bold
 distanza dall’hardware
\series default
 può portare a una suddivisione con: uno strato che definisce astrazioni
 del sistema operativo, uno strato di protocolli di comunicazione e uno
 strato di funzionalità applicative.
\end_layout

\begin_layout Enumerate
il criterio del
\series bold
 tasso di cambiamento atteso 
\series default
suggerisce di separare le funzionalità mettendo in basso le cose più stabili
 e in alto quelle meno stabili (perché così i cambiamenti abbiano un impatto
 che è inversamente proporzionale alla loro frequenza).
\end_layout

\begin_layout Standard
La decomposizione in strati può anche fare riferimento alla combinazione
 di diversi criteri.
\end_layout

\begin_layout Subsection*
Qual è un numero di strati da utilizzare?
\end_layout

\begin_layout Standard
L’obiettivo è favorire un’evoluzione indipendente degli strati.
 Troppi pochi strati potrebbero non separare abbastanza i diversi aspetti
 che il sistema deve gestire.
 Troppi strati potrebbero frammentare eccessivamente l’architettura del
 software – e rendere difficile la sua evoluzione.
\end_layout

\begin_layout Subsection*
Team di sviluppo
\end_layout

\begin_layout Standard
Se Layers viene applicato come decomposizione di primo livello, gli strati
 vengono poi in genere assegnati a team di sviluppo separati.Per favorire
 un’evoluzione indipendente degli strati, la decomposizione in strati dipende
 dall'organizzazione dei team.
 Il costo del coordinamento inter-team è maggiore di quello intra-team.Gli
 obiettivi dei team sono che la maggior parte delle modifiche attese abbiano
 impatto solo su singoli strati (e non si propaghino), e che ogni strato
 dipenda solo in modo debole dagli strati inferiori.
\end_layout

\begin_layout Standard
I sistemi software con un'architettura a strati che sono caratterizzati
 da un accoppiamento elevato – anziché avere parti indipendenti, non raggiungono
 gli obiettivi proposti del pattern.
\end_layout

\begin_layout Subsection*
Conseguenze del pattern
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/layers1.png
	lyxscale 10
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/layers2.png
	lyxscale 10
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/layers3.png
	lyxscale 10
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/layers4.png
	lyxscale 10
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Discussione
\end_layout

\begin_layout Standard
Per sostenere la modificabilità, Layers è basato sui principi di modularità
 e di separazione degli interessi:
\end_layout

\begin_layout Enumerate
un progetto è 
\series bold
modulare
\series default
 se è caratterizzato da accoppiamento basso e coesione alta.
\end_layout

\begin_layout Enumerate

\series bold
il principio di separazione degli interessi 
\series default
tende a separare interessi diversi in elementi differenti.
\end_layout

\begin_layout Standard
Riassumendo:
\end_layout

\begin_layout Itemize
Layers, come gli altri pattern architetturali identifica alcuni tipi specifici
 di elementi e di possibili modalità di interazione tra questi elementi.
 
\end_layout

\begin_layout Itemize
Descrive criteri per effettuare la decomposizione di elementi e delle possibili
 relazioni tra essi.
 
\end_layout

\begin_layout Itemize
Il criterio specifico di identificazione degli elementi/ componenti può
 far riferimento a qualche modalità di modellazione del dominio del sistema.
 
\end_layout

\begin_layout Itemize
Discute la possibilità di raggiungere (o meno) alcuni attributi di qualità.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Pipes and Filters
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Itemize
L'applicazione deve elaborare flussi di dati effettuandone una trasformazione.
\end_layout

\begin_layout Itemize
Una decomposizione basata su meccanismi di tipo richiesta-risposta non è
 adeguata.
\end_layout

\begin_layout Itemize
La trasformazione può essere suddivisa in una sequenza di passi di elaborazione
 – così viene effettuata in modo incrementale.
\end_layout

\begin_layout Itemize
La qualità da sostenere è la modificabilità della trasformazione.
 Non bisogna penalizzare altre qualità.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Itemize
Suddividi la trasformazione in una sequenza di passi di elaborazione dei
 dati auto-contenuti.
\end_layout

\begin_layout Itemize
Ciascun passo di elaborazione viene implementato con un ``filtro'' - o processor.
 
\end_layout

\begin_layout Itemize
La trasformazione complessiva si ottiene collegando i filtri in una pipeline
 di elaborazione dei dati.
 Nella pipeline due filtri successivi sono collegati da una ``pipe”.
\end_layout

\begin_layout Subsection*
Definizioni filtro e pipe
\end_layout

\begin_layout Itemize
Un filtro è un componente che effettua un’elaborazione (di solito semplice)
 del proprio flusso di dati.
 Ha obiettivo di operare una trasformazione (parziale e incrementale) del
 flusso di dati complessivo.
\end_layout

\begin_layout Itemize
Una pipe è un connettore che è un buffer di dati intermedio che collega
 una coppia di filtri
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 13.28.46.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
La compilazione ha lo scopo di trasformare un flusso di caratteri in un
 flusso di istruzioni binarie.
 La trasformazione può essere svolta come una sequenza di passi.
 Seguendo l'archittettura proposta dal pattern Pipe and Filters viene costruita
 una pipeline composta da quattro filtri, ognuna si occupa di una diversa
 passata del compilatore.
 Tra un filtro e il successivo si trova la pipe, che si occupa di far transitare
 i flussi di dati intermedi.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Scenari
\end_layout

\begin_layout Subsection*
Ipotesi preliminari
\end_layout

\begin_layout Enumerate
il flusso dei dati va sempre nella stessa direzione, dalla sorgente verso
 la destinazione.
\end_layout

\begin_layout Enumerate
la gestione del controllo e il numero di elementi attivi cambia da scenario
 a scenario.
\end_layout

\begin_layout Enumerate
Negli scenari 1,2,3, c’è un solo elemento attivo, ossia un solo oggetto
 che vive in un proprio processo o thread di esecuzione distinto dagli altri.
 I filtri, la sorgente e la destinazione potrebbero vivere tutti in un singolo
 processo .
 I filtri portebbero essere dei moduli.
 Le pipe potrebbero essere realizzate mediante chiamate dirette e sincrone.
\end_layout

\begin_layout Enumerate
Nello scenario 4 ci sono più filtri/elementi attivi – in processi e/o thread
 diversi.Le pipe potrebbero essere realizzate in modo asincrono.
\end_layout

\begin_layout Subsection*
Definizioni
\end_layout

\begin_layout Itemize
Data source = sorgente dati.
 È un'entità (ad esempio, un file o un dispositivo di input) che fornisce
 i dati di input al sistema.
 Può spingere attivamente i dati lungo la pipeline o fornire passivamente
 dati quando richiesto, a seconda della situazione.
\end_layout

\begin_layout Itemize
Un data sink è un'entità che raccoglie dati alla fine di una pipeline.
 Può estrarre attivamente i dati dall'ultimo elemento del filtro o può risponder
e passivamente quando richiesto dall'ultimo elemento del filtro.
\end_layout

\begin_layout Subsection*
Pipeline di tipo push
\end_layout

\begin_layout Standard
L'elemento attivo è il data source.
\end_layout

\begin_layout Standard
Il filtro di tipo push definisce un'operazione di tipo write.
\end_layout

\begin_layout Standard
La chiamata write ad un filtro di tipo push serve a spingere dei dati in
 quel filtro, che li elabora e li spinge nel filtro successivo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 13.17.18.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pipeline di tipo push.Data source spinge i dati lungo la pipeline chiamando
 l'operazione write definita dal filtro 1 (il filtro precedente può poi
 chiamare l'operazione write del filtro successivo).
 I dati viaggiano da sinistra verso destra e raggiungono il data sink, che
 li raccoglie.
 La linea di ritorno è opzionale perché non viene restituito niente (nessun
 valore di ritorn).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Pipeline di tipo pull
\end_layout

\begin_layout Standard
L'elemento attivo è il data sink.
\end_layout

\begin_layout Standard
Il filtro di tipo pull definisce un'operazione di tipo read.
\end_layout

\begin_layout Standard
La chiamata read ad un filtro di tipo pull serve a tirare dei dati da quel
 filtro, che a sua volta tira a sé dei dati dal filtro precedente, li elabora
 e restituisce dati elaborati.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 13.17.27.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pipeline di tipo pull.Data sink tira fuori i dati dalla pipeline chiamando
 l'operazione read definita dal filtro 2 (il filtro precedente può poi chiamare
 l'operazione read del filtro successivo).
 Viene chiamata l'operazione read definita dal data source che restituisce
 i dati.
 I dati viaggiano da sinistra verso destra e possono essere elaborati lungo
 la strada.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Pipeline di tipo pull-push
\end_layout

\begin_layout Standard
L'elemento attivo è un filtro, i filtri che lo precedono sono di tipo pull,
 quelli che lo seguono nella pipeline di tipo push.
\end_layout

\begin_layout Standard
Un filtro pull-push ripetutamente tira a sé dei dati dal filtro precedente
 li elabora e poi li spinge nel filtro successivo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 13.17.31.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pipeline di tipo pull-push.
 Il filtro 2 chiama l'operazione read definita dal filtro 1.
 Quando gli vengono restituiti i dati (e dopo averli elaborati), chiama
 l'operazione write definita nel data sink.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Pipeline di tipo pull-push con più filtri attivi
\end_layout

\begin_layout Standard
Tutti i filtri sono attivi e operano in modalità pull-push.
 I diversi filtri lavorano in modo concorrente e asincrono.
 
\end_layout

\begin_layout Standard
Le pipe non solo permettono il transito di dati, ma svolgono il ruolo di
 buffer (permettono di sincronizzare i filtri agli estremi delle pipe) e
 riducono l'accoppiamento dei filtri 
\end_layout

\begin_layout Standard
(un filtro di solito non conosce l'identità dei filtri adiacenti).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 13.17.55.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Pipeline di tipo pull-push con più filtri attivi
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/blank.png
	lyxscale 10
	scale 20

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 13.15.17.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Confronto tra scenari.
 Solo nello scenario 4 i filtri lavorano in modo concorrente e quindi migliorano
 le prestazioni.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Come si applica il pattern?
\end_layout

\begin_layout Enumerate
Si suddivide il compito da svolgere in un gruppo di passi di elaborazione.
\end_layout

\begin_layout Enumerate
Si decide quali filtri siano attivi, quali passivi, come implementare le
 pipe.
\end_layout

\begin_layout Enumerate
Viene progettata strategia per la gestione degli errori.
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 16.39.57.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un altro esempio basato sul pattern Pipe and Filters.
 Una pipeline con un'elaborazione parallela (viene replicato il filtro più
 lento per migliorare le prestazioni)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Discussione
\end_layout

\begin_layout Subsection*
Filtri
\end_layout

\begin_layout Itemize
i filtri possono evolvere in modo indipendente.
\end_layout

\begin_layout Itemize
i filtri possono operare in modo concorrente.
\end_layout

\begin_layout Itemize
talvolta è possibile replicare filtri.
\end_layout

\begin_layout Subsection*
Pipe
\end_layout

\begin_layout Itemize
sono connettori – per la comunicazione, il coordinamento e la sincronizzazione
 tra filtri.
\end_layout

\begin_layout Itemize
sostengono un accoppiamento debole tra filtri.
\end_layout

\begin_layout Itemize
sono possibili diverse implementazioni – ad es.
 come code oppure come canali per messaggi.
\end_layout

\begin_layout Subsection*
Conseguenze del pattern
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/pipe1.png
	lyxscale 10
	scale 20

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/pipe2.png
	lyxscale 10
	scale 22

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/pipe3.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/pipe4.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Tee and join pipeline system
\end_layout

\begin_layout Standard
Il pattern architetturale Tee and join pipeline system è una variante di
 Pipes and Filters.
\end_layout

\begin_layout Itemize
i filtri possono avere più ingressi e/o più uscite.
\end_layout

\begin_layout Itemize
l’elaborazione è un grafo diretto.
\end_layout

\begin_layout Standard
Viene allocato un filtro (thread o processo) per ciascuno defli operatori,
 che venggono poi collegati tramite una pipe line di tipo tee and joy.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 17.00.10.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esecuzione di un'interrogazione SQL.
 Viene allocato un filtro (thread o processo) per ciascuno defli operatori,
 che venggono poi collegati tramite una pipe line di tipo tee and joy.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
architettura esagonale
\end_layout

\begin_layout Subsection*
La Layered Architecture di DDD non soddisfa il principio di inversione delle
 dipendenze.
 
\end_layout

\begin_layout Itemize
i moduli di alto livello (più importanti) non dovrebbero dipendere dai moduli
 di basso livello (meno importanti) – piuttosto, entrambi dovrebbero dipendere
 da opportune astrazioni.
\end_layout

\begin_layout Itemize
le astrazioni non dovrebbero dipendere dai dettagli – piuttosto, i dettagli
 dovrebbero dipendere dalle astrazioni.
\end_layout

\begin_layout Subsection*
Obiettivo
\end_layout

\begin_layout Itemize
le responsabilità di buisness (di alto livello) dovrebbero essere indipendenti,
 cioé non dovrebbero dipendere né dallo strato di presentazione né dallo
 strato infrastrutturale.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 18.12.17.png
	lyxscale 10
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Layered Architecture di DDD
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 19.42.44.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Inversione delle dipendenze.
 Nella figura a sinistra l'Infrastructure Layer definisce e implementa l'interfa
ccia fornita, il Domain Layer la usa.
 Nella figura a destra il Domain Layer definisce l'interfaccia richiesta,
 l'interfaccia viene però implementata nello strato infrastructure.
 Vantaggio: se cambia l'infrastructure Layer non è necessario modificare
 l'interfaccia richiesta.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
È possibile introdurre delle interfacce negli strati della logica di buisness
 per rappresentare le responsabilità infrastrutturali (interfaccia richiesta)
 e poi implementarle nello strato infrastructure.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-08 at 19.57.53.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Layered Architecture dopo il DIP.
 L'infrastructure Layer implementerà tutte le interfacce richieste e quindi
 dipenderà dagli altri strati.
 Gli strati della logica di buisness (application layer + domain layer)
 sono indipendenti rispetto ai combiamenti dello user interface Layer e
 infrastructure Layer
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Per questo si costruisce architettura a strati e DIP per cui:
\end_layout

\begin_layout Standard
L’architettura esagonale, intuitivamente ha origine nell’architettura a
 strati a cui però viene prima applicato il DIP e poi viene rimossa l’asimmetria
 sopra-sotto dell’architettura a strati.
\end_layout

\begin_layout Subsection*
L'architettura esagonale
\end_layout

\begin_layout Standard
In un sistema distribuito, l'architettura esagonale consente di definire
 l’architettura di un singolo componente o servizio software, e di gestire
 le interazioni di questi componenti o servizi.
 
\end_layout

\begin_layout Standard
Questo pattern sostiene un accoppiamento debole tra le responsabilità di
 business e le altre responsabilità.
 Consente un’interazione flessibile tra i servizi – tra di loro e con altre
 entità esterne.
\end_layout

\begin_layout Subsection*

\series bold
Ogni servizio ha sia responsabilità di business che responsabilità di presentazi
one e infrastrutturali
\end_layout

\begin_layout Standard
Ogni servizio è rappresentato da un “esagono”.
 Ogni esagono è inoltre suddiviso in due parti:
\end_layout

\begin_layout Itemize
interno (responsabilità funzionali da componente) che ha responsabilità
 di business + porte.
 Implementa Domain e Application.
\end_layout

\begin_layout Itemize
esterno (responsabilità funzionali da connettore) che ha responsabilità
 di presentazione e infrastrutturali (adattatori).Implementa presentazione
 e infrastrutturali user interface Layer e infrastructure Layer.
\end_layout

\begin_layout Standard

\series bold
Entità esterne:
\series default
 utenti, test automatizzati, la base di dati oppure anche altri servizi.
\end_layout

\begin_layout Standard
La logica di business vuole interagire con le entità esterne.
\end_layout

\begin_layout Standard
Come? La logica di business interagisce con le entità esterne tramite porte
 e adattatori.
\end_layout

\begin_layout Subsection*
Porta
\end_layout

\begin_layout Standard
Una 
\series bold
porta
\series default
 (definita nella logica di business) è un'interfaccia.
 
\end_layout

\begin_layout Standard
Due tipi di porte:
\end_layout

\begin_layout Itemize
inbound port – un’interfaccia fornita (può essere invocata da altri servizi)
\end_layout

\begin_layout Itemize
outbound port – un’interfaccia richiesta (può essere utilizzata per accedere
 ad altri servizi)
\end_layout

\begin_layout Standard
Scopo: interagire con gli utenti, ricevere o effettuare chiamate remote
 da altri servizi, per accedere alla base di dati, per lo scambio asincrono
 di messaggi.
\end_layout

\begin_layout Subsection*
Adattatore
\end_layout

\begin_layout Standard
Un 
\series bold
adattatore
\series default
 (definito nell’esterno del servizio) rappresenta l'implementazione concreta
 dell'interfaccia fornita dalla porta.
\end_layout

\begin_layout Standard
Intuitivamente, implementa lo strato Presentation e lo strato Infrastructure
 del servizio.
\end_layout

\begin_layout Standard
Ciascun adattatore è relativo a una specifica porta, e adatta le interazioni
 con un’entità esterna.
\end_layout

\begin_layout Standard
Ci possono essere uno o più adattatori per ciascuna delle porte.
\end_layout

\begin_layout Standard
Due tipi di adattotori:
\end_layout

\begin_layout Itemize
inbound – può essere invocato da altri servizi/entità esterne: ad esempio
 un utente (entità esterna) che interagisce con il sistema tramite controller
 Springboot (adattatore).
\end_layout

\begin_layout Itemize
outbound – può essere utilizzata per accedere ad altri servizi: il sistema
 che interagisce con la base di dati MySQL (servizio raggiungibile grazie
 ad un outbound port e il relativo adattatore).
\end_layout

\begin_layout Standard
Ciascun adattatore è relativo all’interazione con una specifica tipologia
 di entità esterna – l'interazione richiesta dall’entità esterna viene resa
 compatibile con la logica di buisness e viceversa.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-09 at 10.55.58.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
architettura esagonale.
 Product service, Message listener, DB interface etc...
 sono porte.
 Ogni porta associa un certo numero di adattatori che permettono l'interazione
 con entità esterne come utenti, REST, Kafka etc...
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Esempio 1
\end_layout

\begin_layout Itemize
entità esterna: client 
\end_layout

\begin_layout Itemize
esagono interno: una classe service (che implementa la logica di business)
\end_layout

\begin_layout Itemize
esagono esterno: un controller Springboot (che permette di invocare i metodi
 del service)
\end_layout

\begin_layout Subsection*
Esempio 2
\end_layout

\begin_layout Itemize
entità esterna: database 
\end_layout

\begin_layout Itemize
esagono interno: un'interfaccia repository (un'outbound port)
\end_layout

\begin_layout Itemize
esagono esterno: implementazione di un repository (un'outbound adapter)
\end_layout

\begin_layout Subsection*
Esempio 3
\end_layout

\begin_layout Itemize
entità esterna: un altro servizio 
\end_layout

\begin_layout Itemize
esagono interno: un'interfaccia richiesta (un'outbound port)
\end_layout

\begin_layout Itemize
esagono esterno: API REST (un'outbound adapter)
\end_layout

\begin_layout Subsection*
Scenario
\end_layout

\begin_layout Subsection*
Entità esterna 
\begin_inset Formula $\rightarrow$
\end_inset

 servizio
\end_layout

\begin_layout Enumerate
Un’entità esterna interagisce con un servizio attraverso un adattatore,
 relativo a una porta specifica.
\end_layout

\begin_layout Enumerate
L’adattatore converte questo evento esterno in un’invocazione di un’operazione
 o in un messaggio.
\end_layout

\begin_layout Enumerate
L'invocazione di un'operazione/ messaggio arriva alla logica di buisness
 tramite la porta.
\end_layout

\begin_layout Subsection*
Servizio 
\begin_inset Formula $\rightarrow$
\end_inset

 entità esterna
\end_layout

\begin_layout Enumerate
La logica di business di un servizio deve interagire con l’esterno.
\end_layout

\begin_layout Enumerate
La logica di business interagisce mediante un adattatore di una porta, che
 converte la richiesta o il messaggio in un formato appropriato per l’entità
 esterna.
\end_layout

\begin_layout Subsection*
Vantaggio
\end_layout

\begin_layout Standard
In entrambi i casi, la logica di business è indipendente sia dalla natura
 dell’entità esterna che dagli specifici adattatori utilizzati e dalle tecnologi
e sottostanti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/Screen Shot 2023-02-09 at 11.18.56.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
in un sistema distribuito due servizi interagiscono tramite outbound port
 (interfaccia richiesta) + relativa implementazione, inbound port (interfaccia
 fornita) g usando linguaggi di programmazione differenti.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Conseguenze del pattern
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/esagonale1.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/allegrastrippoli/Library/CloudStorage/OneDrive-UniversitadegliStudiRomaTre/uni I/I semestre/ASW/teoria/esagonale2.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Differenze tra architettura esagonale e layers.
\end_layout

\begin_layout Standard
Un’importante differenza con l’architettura a strati:
\end_layout

\begin_layout Itemize
nell’architettura a strati, gli strati possono essere allocati a team di
 sviluppo separati (team mono-funzionali).
\end_layout

\begin_layout Itemize
nell’architettura esagonale, sono i servizi applicativi che vengono allocati
 a team di sviluppo separati (team cross- funzionali, che si occupano di
 interi servizi).
\end_layout

\begin_layout Subsection*
Decomposizione 
\end_layout

\begin_layout Itemize
La decomposizione di primo livello è quella relativa ai servizi.
\end_layout

\begin_layout Itemize
La decomposizione di secondo livello è tra componenti e connettori.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduzione ai sistemi distribuiti
\end_layout

\begin_layout Standard
Un sistema distribuito è un sistem software che si compone di un insieme
 di elementi, in esecuzione su più nodi, che sono collegati in rete e comunicano
 tra di loro tramite lo scambio di messaggi.Nei sistemi software distribuiti,
 i nodi possono essere costituiti da computer fisici o anche virtuali.
\end_layout

\begin_layout Subsection*
Benefici della distribuzione
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename distribuiti1.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename distribuiti2.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Per complessità accidentale si intende
\end_layout

\begin_layout Enumerate
la rete è affidabile
\end_layout

\begin_layout Enumerate
la latenza è zero 
\end_layout

\begin_layout Enumerate
la banda a disposizione è infinita
\end_layout

\begin_layout Enumerate
la rete è sicura
\end_layout

\begin_layout Enumerate
la topologia della rete non cambia 
\end_layout

\begin_layout Enumerate
c’è un amministratore (che risolve tutti i problemi della rete) 
\end_layout

\begin_layout Enumerate
il costo di trasporto è zero 
\end_layout

\begin_layout Enumerate
la rete è omogenea
\end_layout

\begin_layout Subsection*
Componenti e connettori nei sistemi distribuiti 
\end_layout

\begin_layout Standard
Nei sistemi distribuiti ha un ruolo fondamentale la distinzione tra componenti
 e connettori.
 
\end_layout

\begin_layout Itemize
La distinzione tra componenti e connettori è un’applicazione del principio
 di separazione degli interessi
\end_layout

\begin_layout Itemize
La progettazione dei connettori può essere fatta separatamente da quella
 dei componenti.
\end_layout

\begin_layout Itemize
I connettori sono spesso indipendenti dalle applicazioni – sono potenzialmente
 astratti e riutilizzabili in più contesti.
 Il riuso dei connettori ha permesso la diffusione di servizi di middleware.
\end_layout

\begin_layout Subsection*
Componenti
\end_layout

\begin_layout Standard

\series bold
I componenti sono il luogo della computazione e dello stato.
 (Ossia: i componenti sono sia la sede del processamento, sia la sede della
 gestione/memorizzazione dei dati)
\end_layout

\begin_layout Standard
Ogni componente ha una
\series bold
 specifica di interfaccia
\series default
 che definisce le sue proprietà (funzionali e di qualità).
 Vengono specificati i ruoli che il componente può rivestire, questi ruoli
 (concettuali) diventano porte (implementazione).
\end_layout

\begin_layout Subsection*
Connettori
\end_layout

\begin_layout Standard

\series bold
I connettori sono il luogo delle relazioni tra componenti.
 Sono
\series default
 
\series bold
mediatori di interazioni.
\end_layout

\begin_layout Standard
Ogni connettore ha una 
\series bold
specifica di protocollo 
\series default
che definisce le sue proprietà (ad esempio elenca il tipo di interfacce
 che il connettore è in grado di mediare) e impegni circa sicurezza, affidabilit
à e prestazioni.
 Vengono specificati i ruoli che il connettore deve soddisfare.
\end_layout

\begin_layout Standard

\series bold
esempi: 
\series default
l'invocazione remota è un connettore e ha come ruoli client e server.
\end_layout

\begin_layout Standard
una pipe è un connettore e ha come ruoli write e read.
\end_layout

\begin_layout Standard
un canale è un connettore e ha come producer e consumer.
\end_layout

\begin_layout Itemize
Le caratteristiche fondamentali di un connettore sono:
\end_layout

\begin_deeper
\begin_layout Itemize
la gestione del flusso di controllo (flusso di controllo = l'ordine in cui
 vengono eseguite o valutate singole istruzioni/chiamate di funzione di
 un programma imperativo)
\end_layout

\begin_layout Itemize
la gestione del flusso di dati
\end_layout

\begin_layout Standard
tra due o più componenti.
\end_layout

\end_deeper
\begin_layout Itemize
Ciascun connettore può occuparsi di una o più delle seguenti responsabilità:
\end_layout

\begin_deeper
\begin_layout Itemize
comunicazione – trasferimento di dati tra componenti
\end_layout

\begin_layout Itemize
coordinamento – relativo al trasferimento del controllo tra componenti
\end_layout

\begin_layout Itemize
facilitazione – per mediare l’interazione tra componenti 
\end_layout

\begin_layout Itemize
conversione – di formati e di interazioni
\end_layout

\end_deeper
\begin_layout Subsection*
Relazione tra ruoli e porte (non compare sul libro ma non mi è chiara)
\end_layout

\begin_layout Standard
I ruoli sono specificati nelle interfacce dei componenti e nel protocollo
 dei connettori.
\end_layout

\begin_layout Standard
Specificare che un connettore assumerà il ruolo di client o di server, permette
 di comprendere quale sarà la funzione di quel connettore nell'interazione
 tra componenti.
\end_layout

\begin_layout Standard
Quando un componente ha un'interfaccia richiesta per l'invocazione remota,
 il connettore sa che il suo ruolo è client.
 
\end_layout

\begin_layout Standard
Quando un componente ha un'interfaccia richiesta per consumare messaggi,
 il connettore sa che il suo ruolo è consumer.
 
\end_layout

\begin_layout Subsection*
La composizione dei componenti avviene mettendo in relazione porte di componenti
 con ruoli di connettori.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-09 at 18.12.46.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un connettore X viene usato per comporre i componenti A e B.
 Il connettore X è un connettore per l'invocazione remota.
 Il componente A (client di un servizio S) ha una porta per
\series bold
 l'interfaccia richiesta
\series default
 S.
 Il componente B ha una porta per
\series bold
 l'interfaccia fornita
\series default
 (l'interfaccia è solo una, dal punto di vista del componente è richiesta,
 dal punto di vista del connettore è fornita).
 Il connettore X ha i ruoli 
\emph on
client
\emph default
 e 
\emph on
server.
 
\emph default
La
\emph on
 
\emph default
composizione di A e B (per far fruire ad A il servizio S offerto da B) avviene
 collegando l'interfaccia richiesta di A con il ruolo client di X e l'interfacci
a di B con il ruolo di server di B.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Alcuni esempi
\end_layout

\begin_layout Itemize

\series bold
componenti
\series default
: moduli.
\end_layout

\begin_layout Itemize

\series bold
connettore
\series default
: una chiamata di procedura tra moduli.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Itemize

\series bold
componenti
\series default
: processi.
\end_layout

\begin_layout Itemize

\series bold
connettori
\series default
: una chiamata di procedura remota, una pipe, o un protocollo che regola
 lo scambio di messaggi tra processi.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Itemize

\series bold
componenti
\series default
: un processo e una base di dati.
\end_layout

\begin_layout Itemize

\series bold
connettore
\series default
: l’accesso alla base di dati da parte del processo.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Middleware
\end_layout

\begin_layout Standard
Il middleware è uno strato software che supporta lo sviluppo dei connettori
 nei sistemi distribuiti.
\end_layout

\begin_layout Standard
È un servizio distribuito, general-purpose e multi-piattaforma, che si colloca
 tra piattaforme e applicazioni, e fornisce un'astrazione di programmazione
 distribuita.
 Di solito il middleware viene implementato con API standard e protocolli.
\end_layout

\begin_layout Standard
Grazie ai servizi di middleware gli sviluppatori 
\series bold
riescono a gestire la complessità e l'eterogeneità presenti nei sistemi
 distribuiti
\series default
.
 Lo sviluppo dei connettori è semplificato.
\end_layout

\begin_layout Enumerate
Consentono di mascherare qualche tipo di eterogeneità che può essere presente
 nei sistemi distribuiti, ad esempio nelle reti, nell'hardware, nei sistemi
 operativi o nei linguaggi di programmazione.
\end_layout

\begin_layout Enumerate
Le astrazioni di programmazione offerte dal middleware possono fornire trasparen
za rispetto ad aspetti come posizione, concorrenza, replicazione, fallimenti
 e mobilità.
\end_layout

\begin_layout Standard
Le tecnologie di middleware sostengono diversi stili di comunicazione distribuit
a:
\end_layout

\begin_layout Itemize
invocazione remota 
\end_layout

\begin_layout Itemize
comunicazione asincrona
\end_layout

\begin_layout Standard
L'invocazione remota è uno stile di comunicazione distribuita che viene
 affrontata nel pattern Broker, la comuniczione asincrona invece viene affrontat
a nel pattern Messaging.
\end_layout

\begin_layout Standard
Ci sono diverse famiglie di tecnologie di middleware:
\end_layout

\begin_layout Itemize
middleware per chiamate RPC (basate su invocazione remota).
\end_layout

\begin_layout Itemize
middleware per RMI (basate su invocazione remota).
\end_layout

\begin_layout Itemize
middleware per la comunicazione asincrona.
\end_layout

\begin_layout Itemize
middleware orientato ai servizi (basate spesso ma non obbligatoriamente
 su REST o SOAP?)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-09 at 19.20.47.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Le applicazioni chiamano le API, che sono messe a disposizione dal middleware.
 Il middleware si interfaccia con le varie piattaforme.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Il middleware si colloca tra piattaforme e applicazioni (ChatGPT says)
\end_layout

\begin_layout Standard
Il middleware funge da intermediario tra la piattaforma hardware e software
 sulla quale è in esecuzione un'applicazione e l'applicazione stessa.
 Il middleware fornisce servizi di supporto all'applicazione, come la gestione
 delle comunicazioni tra componenti distribuiti, la gestione della persistenza
 dei dati, la sicurezza e altre funzionalità.
 In questo modo, l'applicazione può concentrarsi sulle proprie attività
 specifiche, senza dover preoccuparsi di tutti i dettagli tecnici sottostanti.
 Il middleware rappresenta quindi un livello di astrazione che semplifica
 la vita agli sviluppatori di applicazioni e rende più facile la creazione
 di sistemi distribuiti.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Stile Client Server
\end_layout

\begin_layout Standard
Lo stile client-server consente a un insieme di client distribuiti di accedere
 ai servizi e alle risorse computazionali offerte da uno o più server.
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Un gran numero di utenti distribuiti vogliono accedere a risorse computazionali
 e servizi condivisi.
 Bisogna gestire e consentire l’accesso all'insieme di queste risorse e
 servizi.
 Si vogliono supportare 
\end_layout

\begin_layout Itemize
modificabilità.
\end_layout

\begin_layout Itemize
riuso di queste risorse e servizi.
 
\end_layout

\begin_layout Itemize
scalabilità.
\end_layout

\begin_layout Itemize
disponibilità.
\end_layout

\begin_layout Subsection*
Soluzione 
\end_layout

\begin_layout Standard
La soluzione proposta dal pattern prevede di organizzare il sistema come
 un insieme di server e di client.
\end_layout

\begin_layout Itemize
Ciascun server è un componente software (un processo) in grado di fornire/erogar
e uno o più servizi ai suoi client.
 
\end_layout

\begin_layout Itemize
Ciascun client è un componente software (un processo) interessato a fruire
 di uno o più servizi da uno o più server.
\end_layout

\begin_layout Itemize
Ciascun servizio rappresenta una funzionalità oppure una risorsa computazionale
 – ed
\series bold
 è caratterizzato da un’interfaccia, basata su un connettore di tipo richiesta-r
isposta.
\end_layout

\begin_layout Subsection*
I client interagiscono invocando i servizi dai server, tramite i relativi
 protocolli richiesta-risposta.
 I server sono responsabili di erogare dei servizi specifici, su richiesta
 dei client.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
Attenzione:
\series default
 parlando di processi si sta facendo riferimento ad elementi runtime.
 Quindi non moduli (che sono elementi statici), e non nodi (che sono elementi
 di deployment).
\end_layout

\begin_layout Subsection*
Qualità dello stile client server
\end_layout

\begin_layout Itemize
Un server può essere acceduto in modo concorrente da molti client (indipendenti
 tra di loro e di più tipologie).
\end_layout

\begin_layout Itemize
I server sono indipendenti dai loro client.
\end_layout

\begin_layout Itemize
Un servizio può essere replicato ed erogato da molti server.
\end_layout

\begin_layout Itemize

\series bold
La possibilità di controllare le risorse e i servizi
\series default
 si deve al fatto che l'accesso a risorse/servizi avviene in genere in uno
 o in pochi server, collocati e governati centralmente.
\end_layout

\begin_layout Itemize

\series bold
La disponibilità e la scalabilità 
\series default
sono sostenute grazie al fatto che risorse/servizi possono essere distribuiti
 e replicati su più server e più nodi (fisici o virtuali).
\end_layout

\begin_layout Itemize

\series bold
La modificabilità 
\series default
è sostenuta dalla centralizzazione di risorse/servizi (la modifica avviene
 in un numero limitato di locazioni).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-09 at 21.07.50.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Pattern di deployment
\end_layout

\begin_layout Standard
Un pattern di deployment rappresenta un modo per allocare i processi di
 interesse su uno o più nodi.
 
\end_layout

\begin_layout Standard
Uno dei concetti principali da introdurre è quello di livello (tier).
\end_layout

\begin_layout Standard

\series bold
Un livello è un nodo o un gruppo di nodi su cui sono rilasciati alcuni processi
 di un sistema client-server.
 
\series default
Un livello è organizzato in base al tipo di servizio che fornisce, ossia
 in base alle responsabilità funzionali che gli sono state assegnate.
 Responsabilità diverse, livelli (e quindi nodi) diversi.
\end_layout

\begin_layout Standard
Il pattern di deployment propone un’architettura a livelli.
\end_layout

\begin_layout Standard
Nella sua storia il pattern client server si è evoluto:
\end_layout

\begin_layout Itemize

\series bold
Pattern client-server a due livelli.

\series default
 Un livello è il client (un nodo o un gruppo di nodi
\series bold
 
\series default
su cui sono rilasciati alcuni processi client), uno è il server.
 Poco scalabile.
\end_layout

\begin_layout Itemize

\series bold
Pattern client-server a tre livelli.

\series default
 Client 
\begin_inset Formula $\rightarrow$
\end_inset

 App Server 
\begin_inset Formula $\rightarrow$
\end_inset

 DB Server.
 Aggiungendo un livello si ha migliore distribuzione del carico di elaborazione
 e migliori prestazioni.
 Supporta disponibilità e scalabilità.
 Tuttavia è aumentata la complessità.
\end_layout

\begin_layout Itemize

\series bold
Pattern client-server a quattro livelli.

\series default
 Client 
\begin_inset Formula $\rightarrow$
\end_inset

 Web Server 
\begin_inset Formula $\rightarrow$
\end_inset

 App Server 
\begin_inset Formula $\rightarrow$
\end_inset

 DB Server.
 Si tratta di un'architettura flessibile, che sostiene prestazioni, disponibilit
à, sicurezza e scalabilità.
 Tuttavia è ancoraaumentata la complessità.
\end_layout

\begin_deeper
\begin_layout Itemize
ChatGPT says: 
\end_layout

\begin_deeper
\begin_layout Standard
Un Web server è progettato per gestire le richieste HTTP e fornire contenuti
 web come pagine HTML, immagini, video e altri file multimediali ai client
 che le richiedono attraverso il web.
 Il compito principale di un Web server è quello di servire contenuti statici
 e dinamici ai client sul web.
\end_layout

\begin_layout Standard
Un App server è progettato per ospitare applicazioni complete e gestire
 le richieste di queste applicazioni, offrendo funzionalità come la gestione
 dei dati, l'elaborazione delle transazioni e la gestione della sicurezza.
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection*
Caratteristiche dello stile client server: Servizi, interfacce (API) e protocoll
i
\end_layout

\begin_layout Itemize

\series bold
Nello stile client-server, ciascun servizio viene ``pubblicato'' mediante
 un’interfaccia
\series default
 (API.
 L'implementazione effettiva del servizio è nascosta dietro l'API e non
 è visibile o accessibile direttamente dal client.)
\end_layout

\begin_deeper
\begin_layout Standard
un'API = interfaccia
\end_layout

\begin_layout Standard
implementazione di un'API = connettore
\end_layout

\begin_layout Standard

\series bold
Ogni API è basata su un connettore, che definisce il protocollo e il formato
 delle richieste e delle risposte scambiate nelle interazioni tra il server
 e i suoi client.
\end_layout

\begin_layout Standard

\series bold
L’applicazione dello stile client-server richiede sempre di definire, per
 ciascun servizio, la sua interfaccia e il relativo protocollo.
\end_layout

\end_deeper
\begin_layout Itemize
L’invocazione dei servizi è di solito sincrona: il client effettua una richiesta
 e rimane in attesa di una risposta.
 Tuttavia, alcuni servizi possono essere invocati in modo ``asincrono''.
 (Questo fa intuire una relazione tra lo stile client server e l'invocazione
 remota supportata dal pattern Broker)
\end_layout

\begin_layout Itemize
L’interazione è asimmetrica: è iniziata dai client, che deve conoscere l’identit
à del server.
 Tuttavia, è possibile che un server possa iniziare delle azioni nei confronti
 dei suoi client – sulla base di meccanismi di notifica o callback.
\end_layout

\begin_layout Subsection*
Stateless stateful e statelss
\end_layout

\begin_layout Standard
Essere stateful/stateless è una caratterizzazione importante dei servizi
 e dei server.
\end_layout

\begin_layout Standard
Una possibile definizione relativa ai 
\series bold
servizi:
\end_layout

\begin_layout Itemize
un servizio è stateful se il suo comportamento dipende da quanto è successo
 nelle sue esecuzioni precedenti.
 Quindi è necessario gestire uno stato
\end_layout

\begin_layout Itemize
Un servizio è stateless se il suo comportamento è indipendente, non ha stato.
\end_layout

\begin_layout Itemize
lo stato deve essere memorizzato dal sistema software nella sua interezza.
\end_layout

\begin_layout Standard
Una possibile definizione relativa ai 
\series bold
server:
\end_layout

\begin_layout Itemize
un server è stateful se scrive oppure legge localmente informazioni circa
 il proprio stato.
 Lo stato viene mantenuto per più esecuzioni successive.
\end_layout

\begin_layout Itemize
un server è stateless se non legge né scrive localmente informazioni circa
 il proprio stato.
\end_layout

\begin_layout Itemize
lo stato deve essere memorizzato dal server localmente.
\end_layout

\begin_layout Standard
(Sostanzialmente il servizio ha un'esigenza, il server la realizza scrivendo/leg
gendo).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Un servizio stateless può essere implementato da un server stateless.
 
\series default
Ogni richiesta può essere gestita indipendentemente dalle altre richieste
 da parte dello stesso client ed è possibile fare pooling delle istanze
 del server (ossia un'istanza può essere condivisa da più client).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-11 at 20.04.22.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un servizio stateless implementato da un server stateless
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Un servizio stateful può essere implementato da un server stateful.
 
\series default
Una possibilità è che per tutta la durata della sessione un client venga
 servito dalla stessa istanza del server.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-11 at 20.04.10.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un servizio stateful implementato da un server stateful
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I server stateless possono essere replicati facilmente, se un servizio è
 stateful, allora il sistema deve gestire (da qualche parte, di solito in
 uno o più dei suoi server) lo stato del servizio.
\end_layout

\begin_layout Standard
Come si gestisce la replicazione in un server stateful?
\end_layout

\begin_layout Standard
Una soluzione comune consiste nell’utilizzare più server per implementare
 (complessivamente) il servizio:
\end_layout

\begin_layout Enumerate
Uno o più server stateful, usati esclusivamente per la memorizzazione di
 dati – ad es., un database server o una cache 
\end_layout

\begin_layout Enumerate
Uno o più server stateless, per la logica di business
\end_layout

\begin_layout Subsection*
Il termine client ed il termine server
\end_layout

\begin_layout Standard
Nello stile architetturale client-server, sono usati per descrivere
\series bold
 l’organizzazione fondamentale complessiva di un sistema distribuito.
\end_layout

\begin_layout Standard
Ma il termine client e server può essere anche usato:
\end_layout

\begin_layout Itemize
localmente per indicare la relazione tra una coppia di elementi architetturali
 (client può chiedere al server ma non viceversa).
\end_layout

\begin_layout Itemize
nel contesto di una singola interazione per indicare la relazione tra una
 coppia di elementi.
\end_layout

\begin_layout Subsection*
Il termine servizio
\end_layout

\begin_layout Standard
Nello stile architetturale client-server, un servizio rappresenta 
\series bold
un insieme di funzionalità
\series default
.
 I servizi sono erogati da componenti server e fruiti da componenti client.
\end_layout

\begin_layout Standard
Nell'architettura a servizi, un servizio è un componente software o un’applicazi
one in grado di erogare un certo insieme di funzionalità.
\end_layout

\begin_layout Standard
Nell'architettura i client e i server sono i componenti software.
 Il server eroga servizi (un insieme di funzionalità).
\end_layout

\begin_layout Standard
Nell'architettura a servizi, i servizi sono i componenti software o applicazioni
 che erogano un insieme di funzionalità.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Stile P2P (saltato)
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Itemize
Un gran numero di utenti fruiscono dei servizi offerti da un insieme di
 entità computazionali distribuite che condividono i loro servizi e risorse.
\end_layout

\begin_layout Itemize
Queste entità sono tra di loro “equivalenti” o “pari”.
\end_layout

\begin_layout Itemize
Si vogliono connettere queste entità sulla base di un protocollo comune.
\end_layout

\begin_layout Itemize
Si vogliono sostenere scalabilità e disponibilità.
\end_layout

\begin_layout Subsection*
Soluzione 
\end_layout

\begin_layout Itemize
Organizza il sistema come un insieme di componenti peer che interagiscono
 tra di loro come “pari”.
\end_layout

\begin_layout Itemize
Ogni peer è un componente software (un processo) – “peer” viene talvolta
 usato anche per indicare un nodo per un peer.
\end_layout

\begin_layout Itemize
I peer sono tutti ugualmente importanti – nessun peer dovrebbe essere critico
 per la salute del sistema o servizio.
\end_layout

\begin_layout Itemize
La comunicazione avviene direttamente da peer a peer (peer to peer), sulla
 base di interazioni richiesta-risposta.
\end_layout

\begin_layout Itemize
Ogni peer fornisce e richiede servizi simili, utilizzando uno stesso protocollo.
 
\end_layout

\begin_layout Itemize
Ogni peer può interagire con ogni altro peer – le interazioni possono essere
 avviate da ciascun peer.
\end_layout

\begin_layout Standard
Lo stile peer-to-peer riflette i meccanismi bidirezionali che possono sussistere
 tra due o più entità che interagiscono tra loro come pari.
\end_layout

\begin_layout Subsection*
P2P in reti controllate - non controllate
\end_layout

\begin_layout Standard
Lo stile peer-to-peer è stato spesso utilizzato in reti P2P non controllate,
 in cui ogni utente è libero di collegarsi in rete e gestire un peer.
\end_layout

\begin_layout Standard
Lo stile peer-to-peer può essere usato anche in reti P2P controllate – come
 un insieme di nodi del data center di un’organizzazione.
 È possibile fornire garanzie sull’effettiva condivisione delle risorse.
\end_layout

\begin_layout Subsection*
Scenari
\end_layout

\begin_layout Itemize
Un servizio comune è la 
\series bold
ricerca
\series default
 di una risorsa – per trovare uno o più peer che possiedono la risorsa cercata.
 Un peer che riceve la richiesta per una ricerca, la effettua localmente
 – ma la può anche propagare ad altri peer.
\end_layout

\begin_layout Itemize
Un altro servizio comune è il 
\series bold
consumo
\series default
 di una risorsa.
 Una richiesta di questo tipo può essere diretta a un solo peer, tra quelli
 che possiedono la risorsa.
 In alcuni casi un peer può consumare la risorsa da più peer, in modo concorrent
e.
 Il peer che riceve una risorsa la può anche memorizzare localmente, per
 poi poterla condividere.
\end_layout

\begin_layout Itemize
Un altro possibile servizio è l’
\series bold
aggiunta
\series default
 di una risorsa.
 Una possibilità potrebbe essere: il peer aggiunge la risorsa localmente,
 e poi inoltra la richiesta ad altri peer, per fare replicare la risorsa.
\end_layout

\begin_layout Itemize
È possibile che un peer (con le sue risorse) venga 
\series bold
rimosso
\series default
 dalle rete P2P.
 La rimozione di un peer non dovrebbe compromettere la disponibilità dei
 servizi offerti dalla rete peer-to-peer.
\end_layout

\begin_layout Itemize
alcune reti P2P hanno dei peer specializzati (super-nodi o super-peer) che
 
\series bold
forniscono servizi comuni o speciali
\series default
 agli altri peer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename P2P1.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-09 at 23.56.50.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Alcuni sistemi sono basati su una combinazione degli stili Client Server
 e P2P – che vengono applicati separatamente in parti distinte del sistema.
 Ad esempio un client di una base di dati potrebbe comunicare con un componente
 server, senza sapere che il componente server in realtà è organizzato seguendo
 un'architettura P2P.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Invocazione Remota
\end_layout

\begin_layout Standard
Definizione nota fino ad ora: l'invocazione remota è uno stile di comunicazione
 supportato dal pattern Broker.
\end_layout

\begin_layout Subsection*
L'invocazione remota è un’astrazione di programmazione distribuita, implementata
 dal middleware.
 Consente interazioni di tipo client/server (sincrone e di tipo richiesta/rispos
ta) tra componenti.
 Si tratta di una versione “remota” dell’invocazione di operazioni “locali”.
\end_layout

\begin_layout Subsection*
Astrazione di programmazione distribuita = un'interfaccia semplificata/meccanism
o che nascondere la complessità della distribuzione al programmatore.
\end_layout

\begin_layout Standard
È implementata da molte tecnologie di middleware ad esempio RPC, RMI.
\end_layout

\begin_layout Subsection*
RPC: Remote Procedure Call
\end_layout

\begin_layout Standard
RPC è un’astrazione di programmazione distribuita.
\end_layout

\begin_layout Standard
Consente a un componente (client) di chiamare (invocare) un'operazione di
 un componente remoto (server), affinché questi esegua l’operazione richiesta.
\end_layout

\begin_layout Subsection*
RMI: Remote Method Invocation
\end_layout

\begin_layout Standard
RMI adotta un modello ad oggetti.
\end_layout

\begin_layout Subsection*
Paradigma dell’invocazione remota
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 09.52.09.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Durante l'esecuzione dell'operazione X viene richiesta l'invocazione remota
 di un'operazione Y.
 L'interazione tra X e Y avviene nell'ambito di due processi distinti (chiamati
 processo client e processo server).
 Invocazione e risultato vengono scambiati mediante messaggi, trasmessi
 in rete o mediante un meccanismo di comunicazione inter processo.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Sintatticamente, l’operazione remota Y viene chiamata da X come se fosse
 un’invocazione locale.
 
\end_layout

\begin_layout Enumerate
In realtà, l’operazione Y vive nel processo server – che è separato dal
 processo client in cui vive X.
 
\end_layout

\begin_layout Enumerate
L’esecuzione di un’invocazione remota comprende certamente le attività consuete
 – passaggio dei parametri, esecuzione dell’operazione e restituzione dei
 risultati.
\end_layout

\begin_layout Enumerate
L’implementazione è basata su un protocollo richiesta-risposta – che prevede
 lo scambio di un messaggio di richiesta e di uno di risposta.
\end_layout

\begin_layout Enumerate
Il client e il server interagiscono in modo sincrono.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 10.05.34.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Questa figura ha un livello di dettaglio maggiore rispetto alla precedente.
 I partecipanti all'interazione sono quattro: client server stub e skeleton.
 Il 
\series bold
client
\series default
 è il componente software che vuole effettuare un'invocazione remota dell'operaz
ione Y.
 Lo 
\series bold
stub
\series default
 (proxy lato client) è un modulo usato dal client per gestire l'invocazione
 remota.
 Vive nel processo client.Lo 
\series bold
skeleton
\series default
 (proxy lato server) è un modulo usato dal server per gestire l'invocazione
 remota.
 Vive nel processo server.Il 
\series bold
server
\series default
 è il componente software che è in grado di eseguire l'operazione Y.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Il client mentre sta eseguendo l'operazione X effettua un'invocazione locale
 dell'operazione Y implementata dallo stub.
\end_layout

\begin_layout Enumerate
Lo stub (proxy lato client) definisce l'operazione Y, tuttavia l'implementazione
 è diversa rispetto a quella proposta dal server.
 Infatti lo stub durante l'esecuzione di Y: prepara un messaggio di richiesta
 e lo invia mediante l'operazione 
\emph on
send
\emph default
.
 Lo stunb si mette poi in ascolto mediante l'operazione 
\emph on
receive
\emph default
.
\end_layout

\begin_layout Enumerate
La request viene ricevuta dallo skeleton (proxy lato server), che si occupa
 di decodificare il messaggio, ossia di estrarre dalla richiesta l'invocazione
 di Y.
 Invoca localmente Y implementata dal server.
\end_layout

\begin_layout Enumerate
Il server esegue l'operazione e restituisce il risultato allo skeleton.
\end_layout

\begin_layout Enumerate
Lo skeleton codifica la risposta e lo invia mediante l'operazione 
\emph on
send
\emph default
.
\end_layout

\begin_layout Enumerate
Lo stub riceve la risposta tramite le receive, la decodifica e restituisce
 il risultato al client.
\end_layout

\begin_layout Subsection*
Proxy
\end_layout

\begin_layout Standard
Un 
\series bold
proxy
\series default
 (pattern GoF) fornisce un surrogato o un segnaposto per un altro oggetto
 – per controllarne l’accesso.
 Nello scenario dei sistemi distribuiti il vantaggio è evidente: i proxy
 remoti nascondono al programmatore il fatto che la comunicazione sia distribuit
a.
\end_layout

\begin_layout Standard
I due proxy remoti implementano un protocollo richiesta-risposta per l’invocazio
ne remota, e le responsabilità principali che gli vengono assegnate sono:
 1.
 inviare e ricevere i messaggi di richiesta e risposta, 2.
 preparare e decodificare i messaggi.
\end_layout

\begin_layout Standard
Con RPC e RMI, i proxy vengono generati automaticamente.
 La generazione automatica dei proxy remoti è basata su linguaggio IDL (linguagg
io per la definizione di interfacce),un compilatore d’interfacce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 11.13.44.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Lo sviluppatore scrive l'interfaccia di un servizio remoto tramite IDL.
 L’implementazione dei proxy remoti è basata su degli opportuni moduli di
 comunicazione, che implementano il protocollo richiesta-risposta sottostante
 all’invocazione remota.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Semantica dell’invocazione remota 
\end_layout

\begin_layout Standard
La semantica (ovvero l'effetto) di un’invocazione remota è la stessa di
 un’invocazione “locale”? No.
\end_layout

\begin_layout Enumerate
Le operazioni sono eseguite in processi e spazi degli indirizzi separati.
\end_layout

\begin_layout Enumerate
Si possono verificare dei problemi di comunicazione.
\end_layout

\begin_layout Enumerate
Il legame dei parametri e dei risultati è gestito diversamente.
\end_layout

\begin_layout Subsection*
Affidabilità
\end_layout

\begin_layout Standard
Nei sistemi distribuiti si possono verificare diversi problemi di affidabilità:
\end_layout

\begin_layout Itemize
fallimenti nella comunicazione.
\end_layout

\begin_layout Itemize
fallimenti nei processi coinvolti.
\end_layout

\begin_layout Standard
Un’invocazione remota potrebbe terminare, per un client, con la ricezione
 di un’eccezione remota.
 
\end_layout

\begin_layout Standard

\series bold
I proxy sollevano l’eccezione remota, i client e i server le ricevono.
\end_layout

\begin_layout Standard
I casi in cui si può verificare un’eccezione remota sono tanti, ecco alcuni
 esempi:
\end_layout

\begin_layout Itemize
Viene perso il messaggio di richiesta oppure di risposta.
 In entrambi i casi, lo stub non riceverà mai il messaggio di risposta e
 dopo la scadenza di un timeout restituirà un'eccezione remota al client.
\end_layout

\begin_deeper
\begin_layout Standard
L’uso di un protocollo di rete a livello di trasporto “affidabile” (come
 TCP) non garantisce l’affidabilità della comunicazione remota (il livello
 di trasporto è affidabile, il livello applicativo no).
 
\end_layout

\begin_layout Standard
I proxy remoti (ed in particolare i loro moduli di comunicazione che implementan
o il protocollo richiesta-risposta) possono essere realizzati per tollerare
 la perdita di alcuni messaggi.
 Esistono diversi approcci (diverse semantiche) per l'invocazione di operazioni
 remote.
 Sono comuni gli approcci: maybe, at least once, at most once.
\end_layout

\end_deeper
\begin_layout Itemize
Il processo server va in crash durante l’esecuzione dell’operazione, oppure
 si blocca in un ciclo infinito.
 Lo skeleton non invierà nessun messaggio di risposta.
 Dopo la scadenza di un timeout lo stub genera l’eccezione.
\end_layout

\begin_layout Standard
Né lo stub né il client saranno in grado di capire quale sia lo scenario
 di fallimento.
 Lo stub solleverà un’eccezione perché è scaduto un timer, ma non è consapevole
 di cosa sia successo effettivamente al sistema.
 
\end_layout

\begin_layout Subsection*
Semantica dell’invocazione remota: maybe, at least once, at most once
\end_layout

\begin_layout Itemize
maybe – il proxy lato client non ripete richieste.
\end_layout

\begin_layout Itemize
at least once – il proxy lato client ripete richieste, il proxy lato server
 non filtra duplicati e semmai chiede al server di rieseguire l’operazione.
\end_layout

\begin_layout Itemize
at most once – il proxy lato client ripete richieste, il proxy lato server
 filtra duplicati e ritrasmette le risposte (senza chiedere al server di
 rieseguire l’operazione).
\end_layout

\begin_layout Standard
Nessuna corrisponde alla semantica exactly once dell’invocazione “locale”.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 11.56.20.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Maybe, at least once, at most once
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La scelta di una semantica piuttosto che di un'altra influenza quanto il
 client può comprendere alla fine dell’invocazione remota.
 Es.
 Con la semantica 
\series bold
Maybe
\series default
, il client sa che l'operazione è stata eseguita al massimo una volta etc...
\end_layout

\begin_layout Standard
Quando si usa uno specifico servizi di middleware, è importante capire qual
 è la semantica dell’invocazione remota che implementa.
\end_layout

\begin_layout Standard
Es.
 Se la semantica è 
\series bold
At-least once
\series default
, allora l’invocazione di un’operazione può causare delle esecuzioni multiple.
 In alcuni casi (quali? per esempio un operazione che aggiorni i dati in
 una base di dati) è opportuno implementare l’operazione in modo idempotente
 (ossia nell'esempio della base di dati, il risultato di molteplici esecuzioni
 dell'operazione non produce molteplici copie del dato, ma solo una.
 In modo più generale si può dire che l'effetto di molteplici esecuzioni
 di un'operazione è uguale all'effetto di una singola esecuzione).
\end_layout

\begin_layout Standard
Inoltre non è detto che una semantica sia sempre più efficace delle altre:
 ad esempio se il processo server è lento a rispondere per un problema di
 carico (ci sono molti thread attivi), la ripetizione delle richieste, soprattut
to con la semantica at-least once, può peggiorare le cose.
\end_layout

\begin_layout Subsection*
Prestazioni
\end_layout

\begin_layout Standard
Il protocollo richiesta-risposta su cui si basa l’invocazione remota introduce
 degli overhead.
 Gli overhead sono dovuti alla codifica e decodifica dei messaggi, e alla
 comunicazione in rete.
\end_layout

\begin_layout Standard
Per minimizzare la penalizzazione sulle prestazioni, è spesso utile minimizzare
 il numero di invocazioni remote, definendo operazioni remote a grana grossa
 (es.
 un metodo che al suo interno fa tante cose).
\end_layout

\begin_layout Subsection*
Concorrenza
\end_layout

\begin_layout Standard
Le operazioni remote possono essere eseguite in modo concorrente tra loro.
\end_layout

\begin_layout Standard
In un processo server, è possibile che ogni volta che il server riceve una
 richiesta, il processo server crea un nuovo thread (pop-up thread) per
 gestirla.
 
\end_layout

\begin_layout Standard
Con la creazione di un nuovo pop-up thread, l’esecuzione dell’operazione
 remota viene gestita in uno stack dedicato alla chiamata remota.
\end_layout

\begin_layout Standard
È possibile che più operazioni remote eseguite in modo concorrente operino
 su risorse condivise.
\end_layout

\begin_layout Subsection*
Serializzazione
\end_layout

\begin_layout Standard
in un’invocazione “locale”, viene di solito passato un riferimento all’oggetto.
 Questo rende possibile effetti collaterali sugli oggetti passati come parametri.
\end_layout

\begin_layout Standard

\series bold
In un’invocazione remota, viene invece passata una rappresentazione serializzata
 dello stato dell’oggetto.
\end_layout

\begin_layout Standard
La serializzazione è il processo di traduzione di una struttura di dati
 o di uno stato di un oggetto in un formato che può essere trasmesso (ad
 esempio, attraverso un collegamento di rete) e ricostruito in un secondo
 momento.
 Quando la serie di bit risultante viene riletta secondo il formato di serializz
azione, può essere utilizzata per creare un clone semanticamente identico
 dell'oggetto originale.
\end_layout

\begin_layout Standard
In RMI, è possibile passare anche dei parametri che sono dei “riferimenti
 remoti” a oggetti remoti.
\end_layout

\begin_layout Subsection*
Invocazione remota “asincrona”, sincrona differita, callback
\end_layout

\begin_layout Standard
Se le operazioni sono di lunga durata e hanno una latenza alta è possibile
 implementare diverse varianti:
\end_layout

\begin_layout Itemize
L'i
\series bold
nvocazione remota asincrona:
\series default
 la chiamata restituisce immediatamente un oggetto (promise oppure future)
 in cui il client potrà accedere in un secondo momento per il risultato.
\end_layout

\begin_layout Itemize

\series bold
L'invocazione remota sincrona differita:
\series default
 il chiamante effettua una prima chiamata per attivare l’operazione remota
 – e poi una seconda chiamata per accedere al risultato dell’operazione.
\end_layout

\begin_layout Itemize

\series bold
Callback
\series default
: il chiamante, al momento dell’invocazione remota asincrona, specifica
 un’operazione (callback) che l’oggetto remoto può invocare per comunicare
 il risultato.
\end_layout

\begin_layout Standard
Si usa il termine 
\begin_inset Quotes eld
\end_inset

asincrona
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

non bloccante
\begin_inset Quotes erd
\end_inset

 perché il client non rimane in attesa della risposta da parte del server.
 Tuttavia si tratta di una forma di comunicazione sincrona perché il client
 e il server devono essere attivi contemporanemante al momento dell'invocazione
 remota.
\end_layout

\begin_layout Subsection*
Locazione del client rispetto al server
\end_layout

\begin_layout Standard
Nell’invocazione remota, il client deve conoscere la locazione in rete del
 server per l’operazione richiesta – ad es., indirizzo IP (oppure nome di
 dominio nel DNS) e porta.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Broker
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Si vuole organizzare un sistema distribuito, con più componenti distribuiti.
 Questi componenti che erogano servizi devono poter essere posizionati in
 rete in modo flessibile.
 I componenti devono poter invocare in modo unificato i servizi di loro
 interesse, in modo indipendente dalla posizione dei componenti.
\end_layout

\begin_layout Standard
Si desidera:
\end_layout

\begin_layout Standard
Supportare un basso accoppiamento, trasparenza nell’accesso ai componenti
 (indipendenza da: 1.
 la locazione 2.
 dai meccanismi di comunicazione interprocesso e 3.
 dalla disponibilità dei componenti) e ove possibile l'interoperabilità
 tra componenti eterogenei.
\end_layout

\begin_layout Standard
Inoltre si vuole mantenere la possibilità di aggiungere, rimuovere o sostituire
 componenti a runtime.
\end_layout

\begin_layout Subsection*
Soluzione 
\end_layout

\begin_layout Standard
La soluzione proposta dal pattern prevede di organizzare il sistema distribuito
 come un insieme di componenti che interagiscono mediante invocazioni remote,
 la comunicazione tra i componenti è gestita da un intermediario, il Broker.
\end_layout

\begin_layout Standard
Un broker (essenzialmente un bus software), consente di strutturare sistemi
 distribuiti con componenti disaccoppiati che interagiscono mediante l’invocazio
ne di servizi remoti.Inoltre sostiene la separazione tra le funzionalità
 applicative e i dettagli della comunicazione.
\end_layout

\begin_layout Standard

\series bold
Il broker definisce un modello di programmazione distribuita, 
\series default
ed è un meccanismo utile per fornire: 1.
 flessibilità rispetto alla locazione dei servizi in rete, 2.
 trasparenza nell’accesso a questi servizi rispetto alla loro locazione.
\end_layout

\begin_layout Standard
Il broker è responsabile di trasmettere richieste e risposte tra client
 e server, e gestisce un registry dei servizi e dei server del sistema distribui
to.
\end_layout

\begin_layout Standard
Offre ai server (mediante delle API) la funzionalità per registrare i loro
 servizi.
\end_layout

\begin_layout Standard
Offre ai client (mediante delle API) la funzionalità per richiedere l’esecuzione
 di servizi.
\end_layout

\begin_layout Standard
I diversi attori che consentono la comunicazione tra componenti client e
 server sono: i proxy e il broker.
 
\end_layout

\begin_layout Subsection*

\series bold
Modello di programmazione distribuita = è un insieme di regole e convenzioni
 che descrivono come i processi distribuiti interagiscono tra loro, include
 le modalità di comunicazione tra i processi, gli schemi di sincronizzazione
 (comunicazione sincrona o asincrona), le politiche di gestione degli errori
 .
\end_layout

\begin_layout Subsection*
Scenari:
\end_layout

\begin_layout Enumerate
Un server, al suo avvio, registra i propri servizi presso il broker.
\end_layout

\begin_layout Enumerate
Un client accede ai servizi indirettamente, tramite il broker.
\end_layout

\begin_layout Enumerate
Il broker seleziona un server in grado di erogare il servizio.
\end_layout

\begin_layout Enumerate
Se un server diviene indisponibile, il broker può scegliere dinamicamente
 di sostituirlo con un altro server.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 13.37.16.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
1) il server si registra presso il broker, che agisce da registry dei servizi.
 2) un client interagisce con il broker per cercare il servizio.
 3) il client invoca il servizio.
 3a) L'interazione tra client e server è mediata da proxy che utilizzano
 i moduli di comunicazione (runtime support) che implementano il protocollo
 richiesta-risposta e utilizzano il supporto per la comunicazione in rete
 fornito dal sistema operativo (network support).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Server 
\end_layout

\begin_layout Standard
Un oggetto o componente che offre servizi, i servizi sono esposti tramite
 un'interfaccia (come specificato nello stile client server).
\end_layout

\begin_layout Standard
Ci sono molti server – ciascuno offre uno o più servizi.
 
\end_layout

\begin_layout Standard
Ogni server registra i propri servizi presso il Broker.
\end_layout

\begin_layout Subsection*
Client 
\end_layout

\begin_layout Standard
Un oggetto o componente che vuole fruire di servizi.
 
\end_layout

\begin_layout Standard
Ci sono molti client concorrenti ,un client inoltra le proprie richieste
 al Broker.
\end_layout

\begin_layout Standard
“Client” e “Server” vanno intesi in modo flessibile (potrebbe essere una
 definizione relativa ad una singola interazione).
\end_layout

\begin_layout Subsection*
Comunicazione diretta - indiretta
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 13.50.58.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
il server chiede al broker di registrare i propri servizi.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 13.51.08.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario di comunicazione indiretta.
 Il client tramite proxy chiede l'erogazione di un servizio al broker.
 Il broker seleziona un server tra i possibili.
 Il broker inoltra la richiesta al server selezionato (inoltra la richiesta
 al proxy del server).
 Il server restituisce la risposta al broker, che la passa a sua volta al
 client.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 13.51.21.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario di comunicazione diretta.
 Il broker mette in comunicazione client e server, ma poi questi comunicheranno
 in modo diretto (tramite proxy).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Confronto tra le varianti
\end_layout

\begin_layout Standard
Nella comunicazione diretta (senza passare due volte per il broker), l’overhead
 di comunicazione è minore.
\end_layout

\begin_layout Standard
Invece nella comunicazione indiretta il client è protetto in modo continuo
 da eventuali indisponibilità e da variazioni di locazione dei servizi (il
 broker cambia quale server assegnare dinamicamente).
 Inoltre la comunicazione indiretta abilita un ulteriore scenario di 
\series bold
interoperabilità
\series default
, in cui il client e il server potrebbero essere eterogenei e potrebbero
 essere basati su protocolli diversi (ad esempio HTTP e FTP) o su formati
 diversi (XML e Jason).
 Lo scenario di interoperabilità viene realizzato introducendo oltre ai
 broker ulteriori componenti, i “bridge”.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename BROKER1.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La prima implementazione di un broker che è stata ampiamente usata è in
 CORBA, il pattern broker è usato, in forme variate ed evolute, anche nelle
 tecnologie a componenti (come Java EE e .NET), nella comunicazione asincrona
 (message broker) e nell’architettura a servizi.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Invocazione remota vs Comunicazione asincrona 
\end_layout

\begin_layout Standard
Premessa doverosa:
\end_layout

\begin_layout Itemize
L’invocazione remota è una forma di comunicazione sincrona, sempre, anche
 nella sua variante asincrona.
 Si usa il termine 
\begin_inset Quotes eld
\end_inset

asincrona
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

non bloccante
\begin_inset Quotes erd
\end_inset

 perché il client non rimane in attesa della risposta da parte del server
 (ad esempio viene notificato attraverso un meccanismo di callback ).
 Tuttavia si tratta di una forma di comunicazione sincrona perché il client
 e il server devono essere attivi contemporanemante al momento dell'invocazione
 remota.
 quindi esiste un momento in cui client e server partecipano contemporaneamente.
 
\end_layout

\begin_layout Itemize
Quando è desiderabile una modalità di interazione meno accoppiata e più
 flessibile, non si vuole l’accoppiamento con uno specifico server, non
 è necessaria la comunicazione sincrona (che è più fragile, può propagare
 rallentamenti o guasti), si utilizza la comunicazione asincrona.
\end_layout

\begin_layout Itemize
La comunicazione asincrona è caratterizzata da un accoppiamento basso perché:
\end_layout

\begin_deeper
\begin_layout Enumerate
l'uso dei messaggi consente disaccoppiamento rispetto alle 
\series bold
operazioni.
 
\series default
I componenti che comunicano però devono essere d'accordo sul formato dei
 messaggi.
 (Chat GPT says: se la comunicazione è asincrona (
\emph on
send 
\emph default
non bloccante) le interfacce fornite non sono bloccate dalle richieste provenien
ti dalle interfacce richiedenti e viceversa).
\end_layout

\begin_layout Enumerate
l'uso dei canali permette disaccoppiamento 
\series bold
spaziale
\series default
 (non è necessario conosce IP, porta, ma i componenti devono essere d'accordo
 sul canale su cui scambiare i messaggi), e 
\series bold
temporale
\series default
 (i consumatori e produttori hanno un esistenza indipendente).
\end_layout

\end_deeper
\begin_layout Standard
Con l'invocazione remota i componenti distribuiti interagiscono:
\end_layout

\begin_layout Itemize
sulla base di un protocollo richiesta-risposta
\end_layout

\begin_layout Itemize
in modo indiretto o diretto (il server può rispondere direttamente al client
 senza passare dal broker)
\end_layout

\begin_layout Itemize
in modo sincrono
\end_layout

\begin_layout Standard
Con la comunicazione asincrona i componenti distribuiti interagiscono:
\end_layout

\begin_layout Itemize
inviandosi messaggi (oppure notifiche di eventi) 
\end_layout

\begin_layout Itemize
in modo indiretto (il produttore invia il messaggio ad un canale per messaggi)
\end_layout

\begin_layout Itemize
in modo asincrono
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Comunicazione asincrona
\end_layout

\begin_layout Standard
Definizione nota fino ad ora: la comunicazione asincrona è uno stile di
 comunicazione supportato dal pattern Messaging.
\end_layout

\begin_layout Subsection*
La comunicazione asincrona è un’astrazione di programmazione distribuita
 basata sullo scambio di messaggi, che consente a un componente (produttore)
 di inviare un messaggio, in modo indiretto e asincrono, a uno o più componenti
 (consumatori) tramite un canale per messaggi.
\end_layout

\begin_layout Subsection*
Perché indiretta?
\end_layout

\begin_layout Standard
Il produttore non trasmette il messaggio direttamente a uno specifico consumator
e.
 Infatti il produttore invia il messaggio ad un canale per messaggi – specifico
 per quel tipo di messaggi.
 
\end_layout

\begin_layout Standard
Il canale per messaggi costituisce un’i
\series bold
ndirezione spaziale
\series default
 nella comunicazione tra produttore e consumatore.
\end_layout

\begin_layout Subsection*
Perché asincrona?
\end_layout

\begin_layout Standard
L’invio e la ricezione del messaggio non sono sincronizzate.
 Dopo che il produttore ha inviato il suo messaggio al canale per messaggi,
 prosegue nel suo lavoro (send-and-forget).Il canale per messaggi costituisce
 anche un’
\series bold
indirezione temporale
\series default
 nella comunicazione tra produttore e consumatore.
\end_layout

\begin_layout Subsection*
Perché implicita?
\end_layout

\begin_layout Standard
La comunicazione asincrona è una forma di 
\series bold
invocazione implicita, 
\series default
ossia l’operazione eseguita non viene scelta sulla base di un’invocazione
 esplicita da parte del produttore del messaggio.
 Inoltre il consumatore sceglie come elaborare il messaggio senza intervento
 del server.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 14.47.41.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Indiretta: il produttore non invia messaggi direttamente al consumatore,
 ma al canale per messaggi.
 Asincrona: il produttore non sa se il consumatore è attivo o se è stato
 creato, in ogni caso invia il messaggio al canale.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'invocazione remota è legata ad architetture client-server, con la comunicazion
e remota invece ogni componente in generale può sia inviare che ricevere
 messaggi, quindi i ruoli di produttore e consumatore sono flessibili.
\end_layout

\begin_layout Subsection*
Pipe and filters e comunicazione asincrona
\end_layout

\begin_layout Standard
In un sistema distribuito basato sulla comunicazione asincrona, vengono
 in genere scambiati una molteplicità di messaggi, tra numerosi componenti
 e tramite molti canali per messaggi.
\end_layout

\begin_layout Standard
L’invio iniziale di un messaggio “trovato” da parte di un componente può
 dare luogo a un’interazione che comprende lo scambio di molti messaggi
 tra più componenti.
 
\end_layout

\begin_layout Standard
Un sistema di questo tipo può essere organizzato sulla base dello stile
 architetturale Pipes and Filters.
\end_layout

\begin_layout Itemize
un filtro è un produttore e/o consumatore.
\end_layout

\begin_layout Itemize
una pipe è canale per messaggi.
 
\end_layout

\begin_layout Itemize
A ciascuna tipologia di messaggi (es.
 un canale per gli Ordini, uno per i pagamenti) corrisponde un canale distinto
 – ogni canale è un “indirizzo logico” per lo scambio di messaggi di quella
 tipologia.
\end_layout

\begin_layout Itemize
Ci possono essere molti componenti (produttore/consumatore) in grado di
 
\series bold
produrre e inviare
\series default
/ 
\series bold
ricevere e consumare
\series default
 messaggi di un certo tipo.
 
\end_layout

\begin_deeper
\begin_layout Standard
“Molti componenti” può voler dire più istanze di uno stesso tipo di componente,
 o anche istanze di tipi di componenti differenti.
 
\end_layout

\begin_layout Standard
Per ciascun canale per messaggi ci possono essere più consumatori registrati
 a quel canale.
\end_layout

\end_deeper
\begin_layout Subsection*
Implementazione della comunicazione asincrona.
\end_layout

\begin_layout Standard
La comunicazione asincrona consente a un produttore di inviare un messaggio,
 in modo indiretto e asincrono, a uno o più consumatori tramite un canale
 per messaggi.
 La comunicazione tra i componenti (produttore/consumatore) è regolata da
 un intermediario, un message broker, che gestisce i diversi canali per
 messaggi.
\end_layout

\begin_layout Standard
Si ricorda (dal pattern Broker,) che un message broker definisce un modello
 di programmazione distribuita.
\end_layout

\begin_layout Standard
Un’implementazione comune è un message broker realizzato come un server
 centralizzato.
 Il server per il message broker viene di solito eseguito su un cluster.
\end_layout

\begin_layout Standard
Quando viene inviato un messaggio su un canale, il message broker assegna
 il compito di consumare quel messaggio ad uno o più tra i consumatori registrat
i al canale.
\end_layout

\begin_layout Itemize
se il canale è point-to-point, a uno solo dei consumatori registrati.
\end_layout

\begin_layout Itemize
se il canale è publish-subscribe, a tutti i consumatori registrati.
\end_layout

\begin_layout Standard
I canali vanno di solito configurati nel message broker prima di iniziare
 lo scambio dei messaggi ma talvolta possono essere definiti in modo dinamico.
 Poi, i componenti si scambiano messaggi, agendo come client nei confronti
 del message broker.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 15.30.33.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Canale point-to-point: più produttori e più consumatori.
 Un messaggio arriva ad UNO SOLO dei consumatori registrati.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 15.17.41.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Canale publish-subscribe: un messaggio arriva a TUTTI i consumatori registrati.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Prestazioni e Scalabilità
\end_layout

\begin_layout Standard
La comunicazione asincrona può supportare prestazioni e scalabilità:
\end_layout

\begin_layout Itemize
I messaggi vengono in genere trasmessi appena possibile, con una latenza
 bassa e un throughput elevato.
\end_layout

\begin_layout Itemize
Le prestazioni e la scalabilità sono favorite anche dalla possibilità di
 utilizzare più componenti consumatori per uno stesso tipo di messaggi.
\end_layout

\begin_layout Standard
La discussione prosegue sulle slides...
 (esempio che supporta prestazioni, scalabilità, modificabilità).
\end_layout

\begin_layout Subsection*
Affidabilità
\end_layout

\begin_layout Standard
Un message broker può offrire diverse opzioni di consegna dei messaggi –
 a cui corrispondono livelli differenti di affidabilità:
\end_layout

\begin_layout Enumerate

\series bold
Consegna non persistente
\series default
 (di tipo best effort): i messaggi possono perdersi.
\end_layout

\begin_layout Enumerate

\series bold
Consegna persistente:
\series default
 i messaggi non possono perdersi, perché il message broker registra in memoria
 secondaria i messaggi che gli vengono inviati.
\end_layout

\begin_layout Enumerate

\series bold
Acknowledgment:
\series default
 un messaggio è considerato consumato con successo quando il consumatore
 a cui è stato assegnato ne conferma la ricezione.
\end_layout

\begin_layout Enumerate

\series bold
Consegna transazionale: 
\series default
un messaggio è considerato consumato con successo quando il consumatore
 a cui è stato assegnato ne conferma l’avvenuta elaborazione.
\end_layout

\begin_layout Standard
L'affidabilità (tolleranza ai guasti) è sostenuta anche da: 1.
 la possibilità di utilizzare repliche ridondanti dei componenti (consumatori)
 2.
 dalla possibilità di eseguire il message broker in un cluster anziché in
 un singolo nodo.
\end_layout

\begin_layout Subsection*
Aspetti temporali
\end_layout

\begin_layout Itemize
Un messaggio inviato a un canale
\series bold
 point-to-point
\series default
 viene in genere conservato fino a quando non è stato consegnato ad un consumato
re – dopo di che, viene cancellato dal canale.
 Tuttavia, è anche possibile assegnare a un messaggio una durata o scadenza.
\end_layout

\begin_layout Itemize
un messaggio inviato a un canale 
\series bold
publish-subscribe
\series default
 viene in genere consegnato a tutti i consumatori attualmente registrati
 presso quel canale – e poi viene cancellato dal canale.
\end_layout

\begin_layout Standard
La memorizzazione dei messaggi nel message broker richiede risorse.
\end_layout

\begin_layout Subsection*
Ordine dei messaggi
\end_layout

\begin_layout Standard
In alcuni casi, un consumatore potrebbe ricevere i messaggi inviati da un
 produttore in un ordine differente da quello in cui sono stati inviati.
 Questo può accadere se il message broker è implementato da un cluster di
 nodi e i messaggi transitano su nodi differenti.
 In alcuni casi, il message broker può fornire meccanismi per garantire
 la consegna in ordine di messaggi correlati.
\end_layout

\begin_layout Subsection*
Perdita e duplicazione di messaggi
\end_layout

\begin_layout Standard
Idealmente, il message broker dovrebbe consegnare ciascun messaggio con
 una semantica exactly-once – tuttavia, la consegna dei messaggi ha in genere
 una semantica at-most-once o at-least-once.
 
\end_layout

\begin_layout Standard
Se opportuno i consumatori dei messaggi devono effettuare elaborazioni idempoten
ti – o ignorare messaggi duplicati, questo può essere problematico se ci
 sono più consumatori per uno stesso tipo di messaggi.
 
\end_layout

\begin_layout Subsection*
Utilizzo di messaggi nelle applicazioni
\end_layout

\begin_layout Itemize
Un evento di dominio rappresenta qualcosa di interessante che è avvenuto
 nel dominio di un componente.
 Ad es.
 “è stato creato un ristorante”, un componente può inviare messaggi relativi
 ai propri eventi di dominio in un canale publish-subscribe specifico.
\end_layout

\begin_layout Itemize
Un comando rappresenta una richiesta di eseguire un’operazione a un componente.
 Un componente può ricevere messaggi che rappresentano comandi in un canale
 point-to-point specifico.
\end_layout

\begin_layout Itemize
Un documento è un messaggio generico che contiene solo dei dati, per ogni
 tipologia di documenti viene utilizzato un canale specifico.
\end_layout

\begin_layout Subsection*
Modalità di consumo dei messaggi
\end_layout

\begin_layout Standard
La ricezione di un messaggio da parte di un consumatore può avvenire secondo
 due modalità principali:
\end_layout

\begin_layout Itemize
polling, su richiesta del consumatore.
\end_layout

\begin_layout Itemize
subscription,  basata su una registrazione dei consumatori al canale.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Messaging
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Alcuni sistemi distribuiti sono composti da componenti debolmente accoppiati
 e che devono operare in modo indipendente.
\end_layout

\begin_layout Standard
Alcune informazioni devono poter essere propagate tra componenti – da componenti
 produttori (producer o publisher) a componenti consumatori (consumer o
 subscriber) – in modo che ogni componente elaborarle nel modo in cui ritiene
 necessario.
\end_layout

\begin_layout Standard
L’interazione tra i componenti deve essere flessibile, deve essere basata
 su un accoppiamento debole, deve avvenire in modo affidabile.
\end_layout

\begin_layout Subsection*
Soluzione 
\end_layout

\begin_layout Standard
La soluzione proposta dal pattern prevede di organizzare il sistema distribuito
 come un insieme di componenti che interagiscono mediante comunicazione
 asincrona, i componenti 
\series bold
sono collegati 
\series default
mediante un intermediario, un bus per messaggi, il Broker.
\end_layout

\begin_layout Standard
Il bus per messaggi si occupa di inoltrare ciascun messaggio dal suo produttore
 ai consumatori interessati a questo messaggio, in modo affidabile – l’inoltro
 è basato sulle registrazioni dei componenti ai tipi di messaggi di loro
 interesse.
\end_layout

\begin_layout Standard
I messaggi possono incapsulare informazioni, strutture di dati o notifiche
 di eventi.
\end_layout

\begin_layout Standard
La codifica dei messaggi consente ai componenti di comunicare in modo debolmente
 accoppiato.
\end_layout

\begin_layout Standard
In modo più specifico, questo pattern può essere applicato anche per supportare
 l’integrazione di componenti indipendenti o autonomi.
 Ad es.
 comporre i componenti di un insieme di applicazioni esistenti per realizzare
 una nuova applicazione, con un maggior valore di business.
\end_layout

\begin_layout Standard
Un termine chiave per capire il pattern è 
\begin_inset Quotes eld
\end_inset

collegamento
\begin_inset Quotes erd
\end_inset

.
 Il collegamento tra componenti avviene tramite connettori.
 di solito, i messaggi vengono scambiati da questi connettori e non direttamente
 dai componenti preesistenti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-10 at 16.20.59.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Osservazione personale (non sta scritta da nessuna parte) così come il pattern
 Broker introduce i Proxy, il pattern Messaging introduce i Message Endpoint.
 
\end_layout

\begin_layout Standard
Per sostenere l'interoperabilità il pattern Broker suggerisce di utilizzare
 la comunicazione indiretta con un broker + dei bridge.
 Il pattern Messaging introduce dei Message Translator.
 In questo modo i vari componenti possono usare diversi formati di dati
 e diversi protocolli.
 Comunque di questo non sono sicurissima.
\end_layout

\begin_layout Subsection*
Pattern di supporto al Messaging
\end_layout

\begin_layout Standard
L’applicazione del Messaging è favorita da ulteriori pattern di supporto,
 che affrontano in modo coerente alcuni problemi ricorrenti della comunicazione
 asincrona.
\end_layout

\begin_layout Enumerate
la comunicazione avviene mediante lo scambio di messaggi.
\end_layout

\begin_layout Enumerate
la comunicazione avviene tramite canali per messaggi.
\end_layout

\begin_layout Enumerate
i componenti vengono collegati ai canali mediante dei message endpoint.
\end_layout

\begin_layout Enumerate
è anche possibile avere degli ulteriori componenti aggiuntivi – ad es.
 per la trasformazione o il routing di messaggi.
\end_layout

\begin_layout Subsection*
Message 
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Consentire uno scambio flessibile di informazioni tra componenti.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Standard
Incapsula le informazioni da scambiare in un messaggio.
 Il messaggio è formato da un body (o payload, che contiene i dati effettivi)
 e da un header (che specifica ulteriori metadati circa i dati trasmessi).
\end_layout

\begin_layout Subsection*
Message Channel
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Per sostenere un accoppiamento debole, i componenti non dovrebbero conoscere
 chi è interessato a quali messaggi.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Standard
I componenti che devono interagire non vengono connessi direttamente, ma
 tramite un canale per messaggi.Un canale per messaggi è un “indirizzo logico”
 presso cui i componenti e servizi possono inviare e ricevere messaggi,
 ne esistono di diversi tipi: canali punto-punto, canali publish-subscribe.
\end_layout

\begin_layout Subsection*
Message Endopoint 
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Si vogliono far comunicare, mediante lo scambio di messaggi, componenti
 autonomi.
\end_layout

\begin_layout Standard
Si vuole sostenere un accoppiamento debole tra i componenti e con la soluzione
 tecnologica di messaging.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Standard
I componenti possono essere connessi mediante dei connettori specializzati,
 chiamati message endpoint (“estremità” per messaggi) che consentono di
 scambiare messaggi.
\end_layout

\begin_layout Standard
Quando un componente deve comunicare dei dati a un altro componente, li
 passa al suo message endpoint – che invia un messaggio a un canale per
 messaggi.
\end_layout

\begin_layout Standard
Questo messaggio non viene ricevuto direttamente dal componente destinatario,
 ma da un altro message endpoint – che ne estrae i dati e li passa al componente
 che li può elaborare.
\end_layout

\begin_layout Standard
Talvolta, non sono i componenti che comunicano direttamente con i loro message
 endpoint – piuttosto, sono i message endpoint che intercettano i dati dai
 componenti a cui sono associati.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-11 at 13.20.56.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Il componente A deve trasmettere dei dati al componente B.
 Lo fa tramite il proprio message endpoint.
 
\series bold
Un message endpoint è un connettore che incapusla tutto il codice per l'accesso
 alle API del message broker.

\series default
 Un message endpoint che ha solo lo scopo di disaccoppiare i componenti
 dalla tecnologia di messaging utilizzata è chiamato un 
\series bold
messaging gateway.
 
\series default
Nell’architettura esagonale, un message endpoint può essere realizzato come
 un adattatore.
 Es.
 un adapter che riceve un messaggio per un comando e invoca un’operazione
 della logica di business.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-11 at 13.25.55.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un channel adapter.
 Un channel adapter nasconde completamente al componente l'infrastruttura
 per lo scambio di messaggi.
 Il componente non è consapevole di essere coinvolto in una comunicazione.Ad
 esempio in un'applicazione per basi di dati un channel adapter potrebbe
 catturare un cambiamento della base di dati.
 Un trigger (una funzione che viene automaticamente eseguita ogni volta
 che si verifica un evento specifico all'interno di un sistema o di un database)
 attiva il channel adapter, che invierà il messaggio al canale per messaggi.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-11 at 13.30.14.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un channel adapter in un'architettura client server.
 Il message endpoint si frappone tra client e server e invia dei messaggi
 su un canale per messaggi.
\end_layout

\end_inset


\end_layout

\end_inset

Chat GPT says:
\end_layout

\begin_layout Standard
Un channel adapter in un'applicazione client-server è un componente che
 fornisce una traduzione tra i formati dei messaggi utilizzati dall'applicazione
 client e quelli utilizzati dall'applicazione server.
 Questo componente è fondamentale per consentire una comunicazione efficace
 tra il client e il server, poiché spesso le applicazioni utilizzano formati
 di messaggi diversi.
\end_layout

\begin_layout Standard
Il channel adapter funziona come un intermediario tra il client e il server,
 traducendo i messaggi inviati dal client in un formato comprensibile per
 il server e viceversa.
 Questo consente al client e al server di comunicare tra loro senza preoccuparsi
 della compatibilità dei formati dei messaggi.
\end_layout

\begin_layout Standard
In generale, un channel adapter viene utilizzato per abilitare una comunicazione
 tra sistemi eterogenei che utilizzano formati di messaggi diversi.
 Può essere implementato come un componente standalone o come parte integrante
 dell'applicazione client o del server.
\end_layout

\begin_layout Subsection*
Message Translator
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Per sostenere un accoppiamento debole, può essere necessario trasformare
 un messaggio dal formato utilizzato dal suo produttore iniziale al formato
 compreso dai suoi consumatori finali – se questi formati sono differenti.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Standard
Vengono introdotti dei traduttori di messaggi (message translator) tra i
 componenti, in grado di convertire messaggi da un formato all’altro 
\end_layout

\begin_layout Subsection*
Message Router 
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
I componenti non dovrebbero avere conoscenza del cammino di instradamento
 da utilizzare.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Standard
Vengono introdotti dei message router che consumano messaggi da un canale
 e li re-inseriscono in altri canali.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Architettura a componenti
\end_layout

\begin_layout Standard
L’architettura a componenti organizza un sistema software come la composizione
 di un insieme di elementi architetturali chiamati “componenti”.
\end_layout

\begin_layout Standard
Uno stile architetturale sostenuto dalle tecnologie a componenti, tecnologie
 che supportano molte qualità architetturalmente significative come prestazioni,
 sicurezza, disponibilità e scalabilità.
 In questo modo lo sviluppo dei componenti e delle applicazioni si possa
 così focalizzare sulle funzionalità applicative.
\end_layout

\begin_layout Subsection*
Cosa si indica con componente.
\end_layout

\begin_layout Standard
(Osservazione: nell'architettura client-server un componente server implementa
 un insieme di funzionalità.
 Questo insieme di funzionalità vengono indicate con il nome di servizio.
 Un servizio è caratterizzato da un'intefaccia.
\end_layout

\begin_layout Standard
Nell'architett ura a componenti non vengono indicati i ruoli di client e
 di server, ma un componente implementa un insieme di funzionalità, e ne
 consente l'accesso tramite interfaccia.
 
\end_layout

\begin_layout Standard
Le definizioni quindi sembrano molto coerenti).
 
\end_layout

\begin_layout Standard
Un componente software è un elemento software che: 
\series bold
1.
 ha delle responsabilità funzionali 2.
 consente l’accesso a queste funzionalità mediante delle interfacce (interfacce
 fornite) 3.
 ha delle dipendenze, specificate mediante interfacce (interfacce richieste).
\end_layout

\begin_layout Standard
Un sistema software viene realizzato come la composizione di più componenti
 software (connessi grazie all'uso di connettori).
\end_layout

\begin_layout Standard
È possibile distinguere due accezioni: una più astratta e generica, l'altra
 concreta e tecnologica.
 
\end_layout

\begin_layout Itemize
Esempi di 
\series bold
teconologie a componenti
\series default
 sono CORBA, Microsoft .NET, Java EE e il framework Spring (basate sul pattern
 broker e legate all'architettura client server).
\end_layout

\begin_layout Itemize
Un 
\series bold
modello a componenti
\series default
 è invece la specifica di uno standard per l’implementazione, la documentazione
 e il rilascio di componenti (Corba Component Model, modello EJB (Java EE),
 modello .NET (Microsoft), il modello a componenti di Spring).
 Ogni modello definisce diverse tipologie di componenti – con obiettivi
 specifici e caratteristiche differenziate.
\end_layout

\begin_layout Itemize
Un 
\series bold
ambiente di esecuzione
\series default
 (o piattaforma) è l’implementazione di un modello per componenti.
 (un application server Java EE, un OS Windows per il modello .NET).
\end_layout

\begin_layout Itemize
La 
\series bold
specifica di un componente
\series default
 definisce un tipo di componente (non si confonda “tipo” con “tipologia”).
 Gran parte della specifica di un componente consiste nella definizione
 di un insieme di interfacce del componente.
 (Come la specifica di interfaccia nell'introduzione ai sistemi distribuiti).
\end_layout

\begin_layout Itemize
Un’
\series bold
implementazione di un componente 
\series default
è una realizzazione di una specifica di componente.
 Per una certa specifica di componente, possono esistere più implementazioni
 di componente che la realizzano.
\end_layout

\begin_layout Itemize
Un 
\series bold
componente installato
\series default
 è una copia di un’implementazione di componente che è stata installata
 su uno specifico ambiente di esecuzione.
\end_layout

\begin_layout Itemize
Un’
\series bold
istanza di componente
\series default
 (o componente oggetto) è un’istanza runtime del componente, creata a partire
 da un componente installato in uno specifico ambiente di esecuzione.
\end_layout

\begin_layout Subsection*
Riassumendo nel caso di un’applicazione web con Java EE:
\end_layout

\begin_layout Itemize
il modello per componenti è Java EE.
\end_layout

\begin_layout Enumerate
l’ambiente di esecuzione è il Server Web Tomcat.
\end_layout

\begin_layout Enumerate
l’implementazione (unità di distribuzione) è il file war – costruito anche
 sulla base di un descrittore di deployment.
 Per essere usata, l’unità di distribuzione deve essere installata/deployata
 sull’Application Server.
\end_layout

\begin_layout Enumerate
richieste HTTP all’applicazione causano/possono causare la creazione di
 oggetti istanza delle classi servlet (una tipologia di componente).
\end_layout

\begin_layout Subsection*

\series bold
Ambiente di esecuzione
\series default
 dei componenti: contenitori per componenti.
\end_layout

\begin_layout Standard
I componenti vivono in ambienti di esecuzione detti contenitori per componenti
 (container o application server).
\end_layout

\begin_layout Standard
Funzioni dei contenitori per componenti:
\end_layout

\begin_layout Enumerate
offrono strumenti di deployment e configurazione che supportano la composizione
 dei componenti in applicazioni, sulla base delle loro interfacce.
\end_layout

\begin_layout Enumerate
si occupano delle dipendenze tra componenti e della gestione del ciclo di
 vita dei componenti e delle loro istanze.
\end_layout

\begin_layout Enumerate
queste tecnologie offrono anche una maggior generalità nei meccanismi di
 comunicazione perché possono comunicare mediante invocazione remota e comunicaz
ione asincrona.
\end_layout

\begin_layout Standard
in questo modo, lo sviluppo dei componenti può essere focalizzato sull’implement
azione delle funzionalità.
\end_layout

\begin_layout Subsection*
Pattern di deployment di applicazioni a componenti
\end_layout

\begin_layout Standard
Le applicazioni a componenti vengono rilasciate utilizzando un pattern di
 deployment su più livelli – ad es., le applicazioni web.
\end_layout

\begin_layout Enumerate

\series bold
livello client
\series default
: gli utenti interagiscono di solito con l’applicazione mediante un browser
 web standard.
\end_layout

\begin_layout Enumerate

\series bold
livello web:
\series default
 componenti web che gestiscono la presentazione (eseguiti in un contenitore
 per componenti weB).
\end_layout

\begin_layout Enumerate

\series bold
livello di business:
\series default
 componenti che realizzano la logica di business (in un contenitore per
 componenti di business)
\end_layout

\begin_layout Enumerate

\series bold
livello dei dati:
\series default
 i dati persistenti dell’applicazione sono di solito gestiti mediante un
 DBMS, esterno ai contenitori per componenti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-12 at 20.35.24.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
architettura di deployment di un'applicazione web a componenti
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
S
\series bold
pecifica di un componente
\series default
 
\end_layout

\begin_layout Standard
Nella specifica di un componente vengono definite un insieme di interfacce
 del componente.
\end_layout

\begin_layout Standard
Esistono due stili principali per le interfacce:
\end_layout

\begin_layout Itemize
Stile procedurale per l’invocazione remota: l’interfaccia è basata su un
 insieme di operazioni e di tipi.
\end_layout

\begin_layout Itemize
Stile orientato ai messaggi: per la comunicazione asincrona e la notifica
 di eventi.
 L’interfaccia è basata su un insieme di tipi di messaggi ed eventi e di
 canali.
\end_layout

\begin_layout Subsection*
Composizione di componenti
\end_layout

\begin_layout Standard
La composizione di un’applicazione a componenti avviene connettendo le interfacc
e dei componenti (richieste e fornite) , in modo da soddisfare le dipendenze
 di ogni componente:
\end_layout

\begin_layout Itemize

\series bold
in sede di specifica
\series default
, avviene connettendo le interfacce fornite e richieste dei componenti,
 specificando quali componenti e come vanno collegati ma senza fare riferimento
 alle loro implementazioni.
\end_layout

\begin_layout Itemize

\series bold
in sede di deployment,
\series default
 bisogna specificare anche l’implementazione scelta per ciascun componente.
\end_layout

\begin_layout Itemize

\series bold
a runtime
\series default
, è necessaria anche una “composizione a runtime” tra le istanze dei componenti.
 Alcuni problemi da considerare: quante e quali istanze di componenti creare?
 quando creare tali istanze? come soddisfare le dipendenze di ciascuna istanza
 di componente? la risposte dipendono da molti fattori, tra cui l’implementazion
e scelta per ciascun tipo di componente etc...
\end_layout

\begin_layout Subsection*
Strategie di creazione dei componenti: individuare lo scope
\end_layout

\begin_layout Standard
Lo scope (“portata” o “scopo”) definisce la strategia per la creazione delle
 istanze dei componenti.
\end_layout

\begin_layout Standard
Definisce quante istanze di componenti creare e quando farlo.
\end_layout

\begin_layout Standard
Viene usato dal contenitore per componenti nella gestione delle istanze
 dei componenti e del loro ciclo di vita.
\end_layout

\begin_layout Standard
Lo scope può dipendere dalla tipologia del componente e dalle dipendenze
 tra i componenti.
\end_layout

\begin_layout Standard
Un esempio di scope è: singleton, prototype, pool.
\end_layout

\begin_layout Subsection*
Limiti iniziali (poi superati)
\end_layout

\begin_layout Standard
L’architettura a componenti nasce come “mono-tecnologica” (non supporta
 l'interoperabilità), sebbene sia un limite che deve essere superato, questo
 consente delle ottimizzazioni altrimenti impossibili – sono tecnologie
 eccellenti per costruire singole applicazioni.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Architettura a servizi
\end_layout

\begin_layout Subsection*
Problema
\end_layout

\begin_layout Standard
Si vuole sostenere l’interoperabilità di componenti distribuiti – scritti
 con linguaggi di programmazione diversi, in esecuzione su piattaforme different
i, forniti da diverse organizzazioni e distribuiti su Internet.
 Si vuole sostenere la scoperta di questi servizi – per poterli poi combinare
 per realizzare delle interazioni significative.Si vogliono ottenere livelli
 di prestazioni, sicurezza e disponibilità accettabili.
\end_layout

\begin_layout Subsection*
Soluzione
\end_layout

\begin_layout Standard
La soluzione proposta dal pattern prevede di organizzare il sistema in termini
 di un insieme di componenti distribuiti che forniscono e/o consumano servizi.
\end_layout

\begin_layout Standard
I componenti fornitori di servizi e i componenti consumatori di servizi
 possono usare linguaggi di programmazione e piattaforme differenti.
\end_layout

\begin_layout Standard
I servizi sono in larga misura indipendenti – sono rilasciati indipendentemente,
 e spesso appartengono a sistemi e organizzazioni differenti.
\end_layout

\begin_layout Standard
I componenti hanno interfacce che descrivono i servizi che forniscono o
 che richiedono a/da altri componenti.
\end_layout

\begin_layout Subsection*
Ancora architettura a servizi
\end_layout

\begin_layout Standard
L’architettura a servizi organizza un sistema software come la composizione
 di servizi interoperabili.
\end_layout

\begin_layout Standard
Un servizio è un elemento architetturale che incapsula una ben precisa funzional
ità di business di un’organizzazione.
\end_layout

\begin_layout Standard
I servizi di interesse possono essere offerti anche da più sistemi software
 diversi, che possono anche appartenere ad organizzazioni separate.
\end_layout

\begin_layout Standard
L’interoperabilità e la componibilità dei servizi rivestono un ruolo fondamental
e.
\end_layout

\begin_layout Standard
Le tecnologie a servizi forniscono dei meccanismi standard di interoperabilità
 (sulla base di protocolli standard per il web), ed in questo modo permettono
 di superare i limiti delle tecnologie a componenti.
\end_layout

\begin_layout Standard
I servizi web hanno l’obiettivo di fornire l’accesso a servizi applicativi
 a dei client software mediante l’adozione di protocolli standard del web,
 per sostenere l’interoperabilità tra componenti e applicazioni software.
\end_layout

\begin_layout Standard
Un’altra caratteristica fondamentale dell’architettura a servizi è la possibilit
à di comporre servizi in modo flessibile.
 La composizione consente di definire un nuovo servizio (servizio composto)
 a partire da un insieme di servizi (componenti).
\end_layout

\begin_layout Standard
La composizione si basa sull’invocazione dei servizi componenti, mediante
 le loro interfacce.
 La flessibilità è maggiore rispetto alla composizione di componenti perché
 1.
 può riguardare servizi di più sistemi o organizzazioni, 2.
 deve poter avvenire sia staticamente (durante lo sviluppo) che dinamicamente
 (a runtime) 3.
 la composizione di servizi deve dare luogo a un nuovo servizio.
\end_layout

\begin_layout Subsection*
Alcune tattiche principali per l’interoperabilità
\end_layout

\begin_layout Itemize

\series bold
interfacce dei servizi:
\series default
 le interazioni tra sistemi devono avvenire tramite delle interfacce, specificat
e in modo neutrale.
\end_layout

\begin_layout Itemize

\series bold
gestione delle richieste e delle risposte: 
\series default
deve essere effettivamente possibile l’invocazione dei servizi, sulla base
 sulle loro interfacce.
\end_layout

\begin_layout Itemize

\series bold
scoperta dei servizi:
\series default
 i consumatori dei servizi devono poter scoprire identità, locazione e interfacc
ia dei servizi di interesse.
\end_layout

\begin_layout Itemize

\series bold
aderire a standard: 
\series default
la standardizzazione è uno degli strumenti principali dell’interoperabilità
 e dell’integrabilità.
\end_layout

\begin_layout Subsection*
Servizi composti e servizi componenti
\end_layout

\begin_layout Standard
La composizione di servizi consente di definire un nuovo servizio composto
 a partire da un insieme di servizi componenti, in modo flessibile.
\end_layout

\begin_layout Standard
Quindi: un servizio componente può essere utilizzato nella composizione
 di più servizi, ma anche un servizio composto può essere riutilizzato come
 servizio componente (per comporre altri servizi).
\end_layout

\begin_layout Standard
La composizione è basata sull’“invocazione” dei servizi componenti.
\end_layout

\begin_layout Standard
Un servizio composto può rappresentare un intero processo di business (business
 process) – ottenuto come composizione di servizi che rappresentano dei
 compiti o delle attività di business, che devono essere svolti in un ordine
 appropriato.
\end_layout

\begin_layout Standard
Due modalità principali di composizione di servizi.
\end_layout

\begin_layout Itemize
Orchestrazione – basata sull’uso di un mediatore.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 09.18.02.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Orchestrazione
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Coreografia – basata su interazioni tra pari, senza un coordinamento centralizza
to.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 09.18.16.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Coreografia
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Orchestrazione e coreografia a confronto
\end_layout

\begin_layout Standard
Si suppone che, quando un nuovo cliente si registra in un sistema, sia necessari
o inviare un’email di conferma al cliente e creare un record per i punti
 fedeltà del cliente.
\end_layout

\begin_layout Itemize

\series bold
nell’orchestrazione
\series default
, il servizio di registrazione del cliente, dopo aver registrato il cliente,
 chiede al servizio di posta elettronica di inviare un messaggio al cliente
 e chiede al servizio dei punti fedeltà di creare un record per il cliente
\end_layout

\begin_layout Itemize
nella coreografia, il servizio di registrazione del cliente, dopo aver registrat
o il cliente, pubblica una notifica dell’evento di registrazione del nuovo
 cliente – gli altri due servizi (quando riceveranno la notifica del nuovo
 cliente) faranno ciò che serve.
\end_layout

\begin_layout Itemize
come gestire il caso in cui ai nuovi clienti sia necessario anche inviare
 un regalo di benvenuto? 
\end_layout

\begin_deeper
\begin_layout Standard
Nell'orchestrazione bisogna modificare il servizio di registrazione, che
 deve fare una richiesta al servizio per l'invio dei regali.
\end_layout

\begin_layout Standard
Nella coreografia non bisogna modificare i servizi esistenti.
 Il servizio per l'invio dei regali deve essere abbonato agli eventi di
 registrazione.
\end_layout

\end_deeper
\begin_layout Subsection*
Capacità fondamentali dei servizi
\end_layout

\begin_layout Standard
Ecco le capacità fondamentali offerte dalle tecnologie a servizi:
\end_layout

\begin_layout Enumerate
interoperabilità
\end_layout

\begin_deeper
\begin_layout Itemize
descrizione di servizi
\end_layout

\begin_layout Itemize
invocazione di servizi 
\end_layout

\begin_layout Itemize
scoperta di servizi
\end_layout

\end_deeper
\begin_layout Enumerate
composizione
\end_layout

\begin_deeper
\begin_layout Itemize
per definire nuovi servizi composti, in modo flessibile
\end_layout

\end_deeper
\begin_layout Subsection*
Attori nell'architettura a servizi
\end_layout

\begin_layout Itemize
un 
\series bold
servizio
\series default
 è un componente o un’applicazione software in grado di erogare un certo
 insieme di funzionalità di business.
\end_layout

\begin_layout Itemize
l’
\series bold
interfaccia di un servizio
\series default
 è la descrizione delle funzionalità del servizio – sulla base di uno standard
 aperto del web.
\end_layout

\begin_layout Itemize
il 
\series bold
fornitore di un servizio
\series default
 è un sistema o un’organizzazione che rende il servizio accessibile – mediante
 la sua interfaccia e tramite tecnologie web standard.
\end_layout

\begin_layout Itemize
un 
\series bold
client
\series default
 (o consumatore) di un servizio è un sistema o un’organizzazione che fruisce
 del servizio – mediante la sua interfaccia e tramite tecnologie web standard.
\end_layout

\begin_layout Itemize
un 
\series bold
service registry
\series default
 (o service broker o service bus) è un servizio per supportare la scoperta
 dei servizi oppure per gestire l’invocazione dei servizi.
\end_layout

\begin_layout Standard
Il collegamento tra servizi può avvenire sulla base di diversi tipi di connettor
i ad es.
 SOAP, REST oppure l’uso di messaggi asincroni.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 00.03.27.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Architettura a servizi (di base)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Il termine servizio
\end_layout

\begin_layout Standard
Nello stile architetturale client-server un servizio rappresenta un insieme
 di funzionalità, un server è un componente che eroga il servizio, e un
 client è un componente che fruisce del servizio.
\end_layout

\begin_layout Standard
Nell’architettura a servizi un servizio è un componente o un’applicazione
 che eroga un certo insieme di funzionalità, l’interfaccia del servizio
 è la descrizione di queste funzionalità, e un client è un componente o
 un’applicazione vuole fruire del servizio.
\end_layout

\begin_layout Subsection*
Principi per la progettazione dei servizi
\end_layout

\begin_layout Standard
Esistono diversi principi che guidano la progettazione dei servizi.
\end_layout

\begin_layout Enumerate

\series bold
i servizi condividono un contratto formale (interfaccia)
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
Ciascun servizio deve condividere la propria interfaccia, per descrivere
 in modo neutrale ogni informazione di interesse per interagire con il servizio
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi realizzano un’astrazione della logica sottostante (incapsulamento).
\end_layout

\begin_deeper
\begin_layout Standard
l’interfaccia è l’unica parte del servizio esposta al suo esterno, l’implementaz
ione del servizio deve essere invisibile e irrilevante per i consumatori
 del servizio.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi possono essere scoperti.
\end_layout

\begin_deeper
\begin_layout Standard
i servizi e le loro interfacce devono poter essere scoperte da chi vuole
 poter utilizzare dei servizi di interesse.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi hanno un’interfaccia accessibile in rete.
\end_layout

\begin_deeper
\begin_layout Standard
i consumatori di un servizio devono poter effettivamente invocare il servizio
 in rete, in modo remoto, sulla base di protocolli standard.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
la locazione dei servizi è trasparente.
\end_layout

\begin_deeper
\begin_layout Standard
I consumatori di un servizio devono poter scoprire dinamicamente la posizione
 del servizio, tramite un registry dei servizi.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi sono debolmente accoppiati.
\end_layout

\begin_deeper
\begin_layout Standard
i servizi devono essere progettati per interagire in modo debolmente accoppiato.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi sono riusabili.
\end_layout

\begin_deeper
\begin_layout Standard
i servizi devono essere progettati per sostenere un potenziale riuso.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi sono componibili.
\end_layout

\begin_deeper
\begin_layout Standard
i servizi devono poter essere utilizzati per comporre altri servizi.
 Questo sostiene la riusabilità, la creazione di livelli di astrazione,
 e la possibilità di creare e modificare rapidamente applicazioni e processi
 di business.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi sono autonomi.
\end_layout

\begin_deeper
\begin_layout Standard
l’autonomia di un servizio riguarda la sua implementazione e il suo ambiente
 di esecuzione.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
i servizi sono stateless.
\end_layout

\begin_deeper
\begin_layout Standard
i servizi non devono gestire informazioni sullo stato delle conversazioni
 con i loro client.
 Questo avrebbe infatti un impatto negativo sul loro accoppiamento, la loro
 riusabilità e la loro componibilità.
\end_layout

\end_deeper
\begin_layout Standard
It doesn’t matter what technology they use.
 HTTP, Corba, pub/sub, custom protocols – doesn’t matter.
 Bezos doesn’t care!
\end_layout

\begin_layout Subsection*
Cloud computing e servizi
\end_layout

\begin_layout Standard
La nozione di servizio riveste un ruolo centrale nel cloud computing – che
 consente l’accesso a risorse di varia natura sotto forma di servizi.
\end_layout

\begin_layout Standard
Tre modelli di servizio principali – Infrastructure aaS, Platform aaS e
 Software aaS – e talvolta si parla anche di XaaS (everything-as-a-service).
\end_layout

\begin_layout Standard
Ad esempio nel modello IaaS (Infrastructure as a Service) il consumatore
 può utilizzare diversi servizi infrastrutturali – come VM, storage e reti.
\end_layout

\begin_layout Standard
L'Infrastructure viene fornita agli utenti del cloud (i consumatori) in
 una modalità che soddisfa i principi per i servizi:
\end_layout

\begin_layout Enumerate
il consumatore accede a questi servizi in rete, mediante una loro interfaccia
 contrattuale e in modo astratto dalla loro implementazione.
\end_layout

\begin_layout Enumerate
il consumatore effettua il provisioning e gestisce i servizi mediante un’API
 REST.
\end_layout

\begin_layout Enumerate
il consumatore può comporre questi servizi, per definire degli ambienti
 di esecuzione complessi.
\end_layout

\begin_layout Enumerate
il fornitore dei servizi ha autonomia sull’implementazione e sulla locazione
 dei servizi.
\end_layout

\begin_layout Standard
Considerazioni analoghe possono essere fatte anche per i modelli PaaS e
 SaaS.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Servizi REST
\end_layout

\begin_layout Standard
Nell’architettura a servizi, un servizio è un componente software che ha
 lo scopo di implementare una insieme di funzionalità.
 Può essere scoperto e invocato dai suoi consumatori mediante un’interfaccia
 aperta e tramite tecnologie standard del web.
\end_layout

\begin_layout Standard
REST (Representational State Transfer) è uno stile architetturale per guidare
 la progettazione di applicazioni web.
 
\end_layout

\begin_layout Standard
Lo stile architetturale REST è uno stile architetturale di tipo client-server
 e i servizi sono di tipo stateless.
\end_layout

\begin_layout Standard
Rest descrive l’architettura del world-wide web, in particolare distingue
 diversi concetti:
\end_layout

\begin_layout Itemize

\series bold
risorsa
\series default
: è un elemento informativo di interesse a cui può essere attribuito un
 nome.
\end_layout

\begin_layout Itemize

\series bold
identificatore di risorsa
\series default
: è un nome univoco utilizzato per identificare una specifica risorsa.
\end_layout

\begin_layout Itemize

\series bold
rappresentazione
\series default
 
\series bold
di una risorsa
\series default
: è un gruppo di dati (e metadati) per una risorsa ad es.
 un documento JSON oppure XML.
 Quando un client accede a una risorsa, gli viene restituita la rappresentazione
 della risorsa in formato JSON oppure XML.
 L’uso delle rappresentazioni consente di disaccoppiare le modalità di memorizza
zione interna delle risorse nei componenti dal modo in cui le risorse vengono
 condivise con l’esterno.
\end_layout

\begin_layout Standard
Lo stile architetturale REST può essere usato anche per guidare la definizione
 di 
\series bold
servizi REST (o RESTful web service o Web API).
 
\series default
Esistono diverse varianti dei servizi REST, l’uso di HTTP non è obbligatorio.
 Tuttavia da ora in avanti viene presentata un’interpretazione comune dei
 servizi REST, basata su HTTP.
 
\end_layout

\begin_layout Subsection*
Principi che guidano la definizione di un servizio REST
\end_layout

\begin_layout Itemize

\series bold
identificazione delle risorse tramite URI.
 
\series default
Un servizio REST espone un insieme di risorse, identificate mediante URI.
\end_layout

\begin_layout Itemize

\series bold
interfaccia uniforme.
 
\series default
Le risorse vengono manipolate in modo uniforme, tramite le operazioni di
 HTTP – come PUT, GET, POST, PATCH e DELETE.
 L’interfaccia di un servizio REST è costituita da un insieme di URI e di
 operazioni HTTP su questi URI.
\end_layout

\begin_layout Itemize

\series bold
messaggi auto-descrittivi.
\series default
Le risorse sono disaccoppiate dalle loro rappresentazioni – il loro contenuto
 può essere acceduto sulla base di più formati.Ogni 
\series bold
richiesta
\series default
 contiene informazioni su come il servizio possa elaborare la richiesta,ogni
 
\series bold
risposta
\series default
 contiene informazioni su come il client possa elaborare la risposta.
\end_layout

\begin_layout Itemize

\series bold
le interazioni con le risorse.

\series default
 Sono stateless, tuttavia è possibile realizzare interazioni stateful utilizzand
o cookie, campi nascosti...
\end_layout

\begin_layout Itemize

\series bold
rappresentazione ipermediale (principio HATEOAS).

\series default
 Una risposta contiene comunemente anche gli identificatori delle risorse
 correlate alla risorsa restituita, per consentire l’accesso a queste risorse.
\end_layout

\begin_layout Subsection*
HATEOAS
\end_layout

\begin_layout Standard
Il principio HATEOAS suggerisce di modellare le relazioni tra risorse in
 modo ipermediale.
\end_layout

\begin_layout Standard
In una risposta, la rappresentazione di una risorsa può includere anche
 dei collegamenti (link) a risorse correlate.
 Ad es.
 in XML, l’elemento link prevede gli attributi href (l’URI della risorsa)
 e rel (che indica il tipo di relazione).
\end_layout

\begin_layout Standard
Inoltre l’interfaccia di un servizio può essere scoperta in modo progressivo.
 Il client ha bisogno di conoscere solo un punto di ingresso al servizio
 – l’uso del servizio può poi proseguire sulla base di questi collegamenti
\end_layout

\begin_layout Subsection*
API basate su comunciazione asincrona: API guidate dagli eventi
\end_layout

\begin_layout Standard
Nel paragrafo sui principi che guidano la definizione di un servizio REST
 è stato presentato un modello che si basa su interazioni di tipo richiesta
 risposta.
 Tuttavia un servizio può offrire anche un’interfaccia basata sulla comunicazion
e asincrona – per la notifica di eventi e lo scambio di messaggi.
 WebHooks, WebSockets e HTTP Streaming sono diverse soluzioni per realizzare
 API guidate dagli eventi (es.
 le GET non vengono richieste dal client ma da dei Message Endpoint).
\end_layout

\begin_layout Subsection*
Vantaggi dei servizi REST
\end_layout

\begin_layout Itemize
l’adozione è semplice – si basano su standard e tecnologie più semplici.
\end_layout

\begin_layout Itemize
è semplice realizzare sia i servizi che i loro client.
\end_layout

\begin_layout Itemize
una tecnologia leggera, con buone soluzioni per la scalabilità.
\end_layout

\begin_layout Itemize
il vantaggio principale di REST è la semplicità
\end_layout

\begin_layout Subsection*
Inconvenienti dei servizi REST 
\end_layout

\begin_layout Itemize
sono adatti soprattutto a scenari con una bassa complessità – per gestire
 risorse informative abbastanza semplici.
\end_layout

\begin_layout Itemize
le infrastrutture per REST non supportano un insieme ampio di attributi
 di qualità – che devono dunque essere gestiti dagli sviluppatori dei servizi.
\end_layout

\begin_layout Itemize
l’accesso ai servizi REST avviene in genere mediante invocazioni remote
 sincrone – l’integrazione di applicazioni può essere problematica.
\end_layout

\begin_layout Itemize
le operazioni HTTP hanno un vocabolario limitato – può essere difficile
 stabilire una buona definizione dell’interfaccia di un servizio REST.
\end_layout

\begin_layout Itemize
manca un supporto standardizzato per la composizione.
\end_layout

\begin_layout Standard
ChatGPT says:
\end_layout

\begin_layout Standard
Un'interfaccia REST (Representational State Transfer) è un'interfaccia web
 basata su HTTP utilizzata per accedere e manipolare le risorse di un'applicazio
ne.
 In una architettura RESTful, le risorse sono identificate da un URL (Uniform
 Resource Locator) e possono essere manipolate attraverso un set di operazioni
 standardizzate, come GET, POST, PUT e DELETE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 12.48.58.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 12.49.12.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quando si usano frasi del tipo: : gli utenti accedono alle risorse virtualizzate
 e ai servizi di cloud computing mediante un’interfaccia web, REST e/o CLI...
 si intende:
\end_layout

\begin_layout Standard
Per gli utenti di accedere alle risorse e ai servizi di cloud computing
 forniti da un provider di cloud (come Amazon Web Services, Google Cloud
 Platform, Microsoft Azure, etc.) attraverso diversi tipi di interfacce.
\end_layout

\begin_layout Standard
L'interfaccia web consente agli utenti di accedere alle risorse e ai servizi
 tramite un browser web, utilizzando una GUI (Graphic User Interface) interattiv
a che semplifica la navigazione e l'uso dei servizi.
\end_layout

\begin_layout Standard

\series bold
L'interfaccia REST (Representational State Transfer) consente agli utenti
 di accedere alle risorse tramite richieste HTTP standard,
\series default
 utilizzando un set di operazioni standardizzate come GET, POST, PUT e DELETE,
 come descritto nella mia risposta precedente.
\end_layout

\begin_layout Standard
Infine, l'interfaccia CLI (Command Line Interface) consente agli utenti
 di accedere alle risorse e ai servizi tramite un'interfaccia testuale basata
 su riga di comando, utilizzando comandi e sintassi specifici del provider
 di cloud.
\end_layout

\begin_layout Standard
In generale, i provider di cloud computing offrono supporto per tutte e
 tre le interfacce (web, REST e CLI) per consentire agli utenti di scegliere
 l'interfaccia più adatta alle loro esigenze.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Architettura a microservizi
\end_layout

\begin_layout Standard
L’architettura a microservizi è un importante caso specifico di “architettura
 a servizi”.
\end_layout

\begin_layout Standard
Un'importante differenza tra l'architettura a microservizi e quella a servizi
 sta nel fatto che l'architettura a microservizi ha lo scopo di definire
 una singola applicazione, e non un'architettura complessiva di tutte le
 applicazioni e sistemi software di un'organizzazione.
 Inoltre nell'architettura a microservizi si suggerisce l'utilizzo di metodi
 agili e di meccanismi di comunicazione leggeri (per questo micro-servizi
 servizi, leggeri non pesanti).
\end_layout

\begin_layout Standard
Problemi affrontati dall’architettura a microservizi:
\end_layout

\begin_layout Itemize
è richiesta un’elevata scalabilità – l’applicazione ha milioni di utenti
 in tutto il mondo.
\end_layout

\begin_layout Itemize
è richiesta un’alta disponibilità – un’interruzione di servizio dell’applicazion
e è anche un’interruzione del business.
\end_layout

\begin_layout Itemize
è richiesta agilità di business – deve essere possibile offrire rapidamente
 funzionalità e caratteristiche sempre migliori o innovative nell’ambito
 di questa applicazione.
\end_layout

\begin_layout Itemize
l’applicazione potrebbe essere stata inizialmente sviluppata in modo monolitico
 – deve essere reingegnerizzata affinché possa soddisfare tutti questi requisiti
\end_layout

\begin_layout Standard
La soluzione dell’architettura a microservizi:
\end_layout

\begin_layout Itemize
l’intera applicazione viene definita come l’integrazione e la composizione
 di un insieme di microservizi.
 
\end_layout

\begin_deeper
\begin_layout Standard
(Non sono sicura ma: nell'architettura a microservizi l’
\series bold
intera
\series default
 applicazione è definita come la composizione di un insieme di microservizi.
 Invece nell'architettura a servizi un singolo servizio potrebbe essere
 un’intera applicazione software (che viene poi composto con altri servizi).
 
\begin_inset Quotes eld
\end_inset

Potrebbe
\begin_inset Quotes erd
\end_inset

 perché in realtà in servizio potrebbe essere anche solo un componente in
 grado di erogare un certo insieme di funzionalità.
 
\end_layout

\begin_layout Enumerate
Esempio 1: Un'intera applicazione Springboot potrebbe essere un servizio
 di un'architettura a servizi.
\end_layout

\begin_layout Enumerate
Esempio 2: Sempre usando Spring Boot, un servizio potrebbe essere un componente
 software che implementa la logica di business (una classe annotata con
 @Service).
 Questi servizi possono essere utilizzati all'interno di una più grande
 architettura a servizi.
 Ad esempio un controller Rest potrebbe far si che i metodi scritti dalla
 classe @Service vengano invcati da altri servizi.
\end_layout

\begin_layout Standard
Inoltre chat GPT says:
\end_layout

\begin_layout Standard
Nell'architettura a microservizi, un servizio è un componente software 
\series bold
autonomo
\series default
 che esegue una specifica funzione all'interno dell'applicazione.
 
\series bold
Questi servizi sono progettati per essere distribuiti e gestiti in modo
 indipendente, il che li rende facilmente sostituibili o scalabili.

\series default
 La composizione dei servizi nell'architettura a microservizi da come risultato
 la creazione di un'applicazione.
\end_layout

\begin_layout Standard
Nell'architettura a servizi, un servizio è un componente software che esegue
 una specifica funzione all'interno di un'applicazione e può essere utilizzato
 da altri componenti dell'applicazione.
 Tuttavia, a differenza dell'architettura a microservizi, 
\series bold
i servizi nell'architettura a servizi non sono progettati per essere distribuiti
 e gestiti in modo indipendente.
\end_layout

\begin_layout Standard

\series bold
In sintesi, l'architettura a microservizi si concentra sulla creazione di
 servizi autonomi che possono essere distribuiti e gestiti in modo indipendente,
 mentre l'architettura a servizi si concentra sulla creazione di servizi
 che possono essere utilizzati da altri componenti dell'applicazione/ del
 sistema.
\end_layout

\end_deeper
\begin_layout Itemize
Ogni microservizio è un servizio coeso e “piccolo”, rappresenta una specifica
 capacità di business in modo autocontenuto e in esecuzione in un proprio
 processo.
\end_layout

\begin_layout Itemize
i microservizi sono autonomi – possono essere realizzati con tecnologie
 software differenti.
\end_layout

\begin_layout Itemize
i microservizi comunicano sulla base di meccanismi leggeri.
\end_layout

\begin_layout Itemize
i microservizi possono essere rilasciati in modo completamente automatizzato
 e indipendente tra loro.
\end_layout

\begin_layout Itemize
i client dell’applicazione interagiscono con i microservizi in modo indiretto,
 mediante un API gateway.
\end_layout

\begin_layout Itemize
è in genere necessario un minimo di controllo centralizzato e di supporto
 infrastrutturale per i microservizi 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 14.53.55.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Architettura a microservizi 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
È bene soffermarsi su alcuni dei punti offerti dalla soluzione:
\end_layout

\begin_layout Standard
Ciascun microservizio è 
\series bold
coeso
\series default
 e rappresenta una singola capacità di business.
 I microservizi sono unità di sviluppo fortemente modulari per favorire
 la modificabilità dell’applicazione.
 La coesione e la modularità sono alcune tra le caratteristiche più importanti
 dei microservizi.
\end_layout

\begin_layout Standard
I microservizi sono 
\series bold
componibili, 
\series default
la composizione deve essere flessibile – in modo da poter integrare nuovi
 microservizi quando vengono sviluppati.
 
\series bold
La modalità di composizione scelta di solito è la coreografia di microservizi,
 e la forma preferita di comunicazione tra i microservizi è la comunicazione
 ascincrona.
 
\series default
Questo consente infatti di aggiungere nuovi microservizi alla coreografia,
 senza modificare i microservizi già esistenti.
 
\end_layout

\begin_layout Standard
Ove necessario, la composizione può essere realizzata anche come un’orchestrazio
ne – basata sull’invocazione remota.
\end_layout

\begin_layout Standard
La composizione di microservizi può avvenire anche in altri modi, non solo
 a livello di logica di buisness, ma a livello di interfaccia (ciascun microserv
izio può avere una propria UI, che può contenere link alle UI di altri microserv
izi) utente o al livello della base di dati (più microservizi accedono a
 una base di dati condivisa, sconsigliato).
\end_layout

\begin_layout Standard
L'invocazione remota è spesso basata su chiamate REST mediante HTTP, la
 comunicazione asincrona può essere basata sullo scambio di messaggi e la
 notifica di eventi, mediante un message broker leggero.
 La comunicazione asincrona offre numerosi vantaggi rispetto all’invocazione
 remota sostiene modificabilità, scalabilità, disponibilità e affidabilità,
 tuttavia, offre un supporto limitato alla consistenza dei dati (non vi
 è alcuna garanzia che i dati siano sempre coerenti o che non vi siano errori
 nella trasmissione dei dati.
 ).
\end_layout

\begin_layout Standard
Ciascun microservizio costituisce un’entità software 
\series bold
autonoma.
 
\series default
I diversi microservizi possono essere sviluppati con tecnologie software
 differenti e rilasciati in esecuzione in processi separati.
 L’eterogeneità viene risolta mediante l’uso di meccanismi di comunicazione
 interoperabili.
\end_layout

\begin_layout Standard
l’autonomia dei microservizi consente di:
\end_layout

\begin_layout Itemize
sviluppare e verificare ciascun microservizio separatamente dagli altri.
\end_layout

\begin_layout Itemize
rilasciare ciascun microservizio separatamente dagli altri.
\end_layout

\begin_layout Itemize
replicare ciascun microservizio separatamente dagli altri.
\end_layout

\begin_layout Itemize
sostituire un microservizio con una sua nuova implementazione, se e quando
 necessario.
\end_layout

\begin_layout Standard
L’autonomia si riferisce anche ai team di sviluppo.
 I team possono prendere decisioni di progetto autonome riguardo ai microservizi
 di cui sono responsabili.
\end_layout

\begin_layout Standard
Il 
\series bold
rilascio di nuove versioni dei microservizi è indipendente e automatizzato
\series default
.
 Un rilascio potrebbe riguardare l’aggiornamento di un microservizio X da
 una versione A ad una nuova versione B.
\end_layout

\begin_layout Standard
Deve poter avvenire frequentemente, deve avvenire in modo affidabile.
 Per questo, avviene in modo automatizzato – adottando la Continuous Delivery
 (in particolare, la deployment pipeline e il rilascio senza interruzioni
 di servizio).
\end_layout

\begin_layout Subsection*
Capacità di business
\end_layout

\begin_layout Standard
Una capacità di business (business capability) è un’attività o un compito
 che un’organizzazione fa o può fare – al fine di generare valore di business.
\end_layout

\begin_layout Standard
Ciascun microservizio rappresenta una (singola) capacità di business in
 modo autocontenuto (e si occupa di 
\series bold
tutti
\series default
 gli aspetti relativi a una specifica capacità di business – logica di business,
 UI e gestione dei dati persistenti).
 Es.
 se la capacità di buisness è la gestione degli ordini,un microservizio
 di occupa di gestire interfaccia, database e implementa la logica di buisness.
\end_layout

\begin_layout Standard
È compatibile con i team di sviluppo cross-funzionali.
\end_layout

\begin_layout Subsection*
La legge di Conway
\end_layout

\begin_layout Standard
Ogni organizzazione che progetta sistemi produrrà inevitabilmente dei progetti
 che sono una copia della struttura di comunicazione dell’organizzazione.
 Questo per dimostrare che i team cross-funzionali daranno vita ad architetture
 come quella a monoservizi.
\end_layout

\begin_layout Subsection*
Gestione decentralizzata dei dati
\end_layout

\begin_layout Standard
Un microservizio si occupa direttamente anche della gestione dei dati per
 la capacità di business che rappresenta.
 L’uso di basi di dati separate sostiene l’autonomia dei microservizi –
 ogni microservizio può gestire i propri dati usando la tecnologia più opportuna.
Sostiene una coesione alta e un accoppiamento basso.
 Sostiene la scalabilità – una base di dati monolitica potrebbe invece ostacolar
e la scalabilità dell’intera applicazione.
\end_layout

\begin_layout Standard
Tuttavia, la gestione decentralizzata dei dati pone anche dei problemi e
 solleva delle sfide.
\end_layout

\begin_layout Standard
Se un microservizio ha bisogno dei dati di un altro microservizio, non li
 può accedere direttamente dalla relativa base di dati.
 Una soluzione comune consiste di gestire separatamente l'accesso ai dati
 più importanti su delle repliche, usando il pattern CQRS.
\end_layout

\begin_layout Subsection*
API gateway
\end_layout

\begin_layout Standard
Un’applicazione a microservizi può esporre le proprie funzionalità al suo
 esterno sotto forma di applicazione web, app mobile o come API REST – per
 consentire l’accesso mediante una molteplicità di dispositivi e di client.
 I client finali però non devono interagire direttamente con i microservizi
 dell’applicazione (per evitare accoppiamento tra client e microservizi).Per
 questo si introduce un API gateway, un servizio (lato server) che fornisce
 un’API specializzata e un punto di accesso unificato a un’applicazione
 composta da più microservizi.
 Effettua il routing delle chiamate dei client ai servizi specifici di interesse.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 16.07.37.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un API gateway che si frappone tra client e microservizi.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Un minimo di gestione centralizzata
\end_layout

\begin_layout Standard
Le principali decisioni tecniche e infrastrutturali da prendere a livello
 dell’intero sistema – in modo standardizzato e centralizzato.
 1.
 protocolli e standard di comunicazione ad es., la scelta del message broker,
 
\end_layout

\begin_layout Standard
2.
 approcci standard per la gestione dei dati di configurazione 3.
 la scoperta dei microservizi (service discovery) 4.
 la sicurezza 5.
 l’automazione dell’infrastruttura e il rilascio automatizzato dei microservizi
 (continuous delivery) 5.
 il monitoraggio e il logging.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 16.20.50.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 16.20.59.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 16.21.10.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Dal monolito ai microservizi
\end_layout

\begin_layout Standard
Ciascun microservizio deve rappresentare una singola capacità di business
 in modo autocontenuto.
 La decomposizione avviene in modo iterativo e incrementale.
\end_layout

\begin_layout Standard
Il pattern Strangler, che suggerisce:
\end_layout

\begin_layout Itemize
di aggiungere un API gateway di fronte all’applicazione.
 L’API gateway inoltra le richieste degli utenti finali verso i nuovi microservi
zi oppure verso la vecchia applicazione.
\end_layout

\begin_layout Itemize
di sostituire (in modo iterativo e incrementale) pezzi specifici di funzionalità
 dell’applicazione con nuovi microservizi.
 Contestualmente, queste funzionalità vengono “spente” dall’applicazione
 originale.
\end_layout

\begin_layout Standard
La migrazione delle funzionalità avviene dunque in modo graduale.
\end_layout

\begin_layout Subsection*
Microservizi e DDD
\end_layout

\begin_layout Standard
La decomposizione di un’applicazione in microservizi può essere guidata
 dall’applicazione di Domain-Driven Design (DDD).
 DDD è un approccio allo sviluppo di sistemi software complessi.
\end_layout

\begin_layout Subsection*
Microservizi e architettura esagonale
\end_layout

\begin_layout Standard
Ogni microservizio può essere implementato come un “esagono” (servizio).
\end_layout

\begin_layout Itemize
L’interno (la logica di business) rappresenta una capacità di business in
 modo autocontenuto.
 
\end_layout

\begin_layout Itemize
Le porte rappresentano le interfacce (fornite e richieste) del microservizio.
\end_layout

\begin_layout Itemize
Gli adattatori consentono di implementare queste porte in modo interoperabile.
\end_layout

\begin_layout Subsection*
Microservices Patterns
\end_layout

\begin_layout Standard
Sulle slides...
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduzione alla delivery del software e a DevOps
\end_layout

\begin_layout Standard
La delivery di un sistema (o di un servizio) software è l’attività di rilascio
 e consegna del software (o di una sua nuova versione) ai suoi utenti finali
 affinché lo possano effettivamente utilizzare.
\end_layout

\begin_layout Subsection*

\series bold
Processo di delivery
\end_layout

\begin_layout Standard
Gli interessi principali sono gli ambienti di esecuzione e il 
\series bold
processo di delivery.
\end_layout

\begin_layout Standard
Il processo di delivery richiede diversi passi:
\end_layout

\begin_layout Itemize

\series bold
build
\series default
 (costruzione) – la compilazione e l’assemblaggio del codice in un formato
 adatto per l’installazione.
\end_layout

\begin_layout Itemize

\series bold
deployment
\series default
 (installazione) – l’installazione del software in un ambiente di esecuzione
 – può richiedere anche il provisioning (preparazione) dell’ambiente.
\end_layout

\begin_layout Itemize

\series bold
test
\series default
 (verifica) – l’esecuzione di test per verificare le funzionalità e le qualità
 del software.
\end_layout

\begin_layout Itemize

\series bold
release
\series default
 (rilascio) – l’effettivo rilascio del software agli utenti, nell’ambiente
 di produzione.
\end_layout

\begin_layout Standard
Molte altre organizzazioni eseguono oggi la delivery del software in modo
 automatizzato.
\end_layout

\begin_layout Subsection*
Ambienti
\end_layout

\begin_layout Standard
Un ambiente di esecuzione per un sistema software comprende le risorse di
 calcolo (hardware e software) necessarie per poter eseguire il sistema
 software, insieme alle loro configurazioni.
\end_layout

\begin_layout Standard
Ad es.
 per eseguire un’applicazione web si potrebbero utilizzare più nodi – un
 web server, un application server e un database server – collegati in rete
 e replicati opportunamente.
\end_layout

\begin_layout Standard
(Nei capitoli precedentti avevamo visti come ambienti di esecuzione un Web
 Server Tomcat, un Application Server Java EE, etc...
 sono ambienti di esecuzione o piattaforme?)
\end_layout

\begin_layout Standard
Gli esempi di risorse hardware (fisici o virtuali): 1.
 server fisici, 2.
 macchine virtuali e 3.
 container, con diverse possibilità sulla locazione (data center/ cloud).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-13 at 18.41.26.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ambiente per un'applicazione web
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un sistema software richiede in genere 
\series bold
più ambienti: 
\series default
1.
 l’ambiente di produzione (es.
 un server su cui girano container e macchine virtuali) 2.
 l’ambiente di sviluppo (es.
 un computer personale che ha un IDE) 3.
 uno o più ambienti di test .
\end_layout

\begin_layout Standard
ChatGPT says:
\end_layout

\begin_layout Standard
L'ambiente di esecuzione include tutte le risorse (il sistema operativo,
 le librerie di sistema, i driver di dispositivo e altri software di supporto)
 necessari per eseguire un'applicazione.
\end_layout

\begin_layout Standard
L'ambiente di esecuzione può variare in base alla piattaforma di destinazione,
 come ad esempio il sistema operativo o il tipo di dispositivo.
 Ad esempio, un'applicazione che viene eseguita su un sistema operativo
 Windows avrà un ambiente di esecuzione diverso da un'applicazione che viene
 eseguita su un sistema operativo Linux o su un dispositivo mobile.
\end_layout

\begin_layout Standard
L'ambiente di esecuzione fornisce all'applicazione l'accesso alle risorse
 di sistema, come la memoria, i file system, i dispositivi di input/output
 e le connessioni di rete.
 Inoltre, l'ambiente di esecuzione può influire sulle prestazioni dell'applicazi
one e sulla sua capacità di sfruttare le funzionalità hardware disponibili
 sul dispositivo di esecuzione.
\end_layout

\begin_layout Standard
In sintesi, l'ambiente di esecuzione rappresenta il contesto in cui un'applicazi
one viene eseguita e include il sistema operativo, le librerie di sistema
 e altri software di supporto necessari per l'esecuzione dell'applicazione.
\end_layout

\begin_layout Subsection*
Gestione di ambienti
\end_layout

\begin_layout Standard
La delivery di un sistema software – in particolare, il suo deployment –
 può richiedere anche la preparazione dell’ambiente.
\end_layout

\begin_layout Standard

\series bold
Nel provisioning di un ambiente, l’hardware (fisico o virtuale) viene acquisito
 e configurato, e in ogni nodo viene installato e configurato il software
 richiesto (OS e middleware).
 
\end_layout

\begin_layout Standard
Il provisioning e il deployment possono essere svolti in modo automatizzato,
 grazie all’utilizzo di strumenti per la gestione delle configurazioni e
 degli ambienti, basati su un approccio di tipo 
\series bold
infrastructure as code.
\end_layout

\begin_layout Standard
 Infrastructure as Code (IaC) è un approccio alla gestione e al provisioning
 dell'infrastruttura che avviene tramite codice anziché con processi manuali.
\end_layout

\begin_layout Subsection*
DevOps
\end_layout

\begin_layout Standard
DevOps è un insieme di pratiche che hanno lo scopo di ridurre il tempo tra
 quando viene effettuato il commit di un cambiamento di un sistema software
 e quando il cambiamento viene effettivamente rilasciato in produzione,
 garantendo allo stesso tempo un’alta qualità (definizione tecnica.)
\end_layout

\begin_layout Standard
La principale pratica tecnica DevOps è la Continuous Delivery (CD), per
 automatizzare i rilasci del software.
\end_layout

\begin_layout Subsection*
Piattaforme 
\end_layout

\begin_layout Standard
Una piattaforma è un ecosistema di risorse per implementare ed eseguire
 applicazioni software.
 Due tipi principali di risorse:
\end_layout

\begin_layout Itemize
un insieme di strumenti software per sviluppare applicazioni.Compiltori,
 librerie, debugger etc...
\end_layout

\begin_layout Itemize
un ambiente runtime per eseguire queste applicazioni.
 (Java EE e Microsoft .NET)
\end_layout

\begin_deeper
\begin_layout Standard
once again chat GPT says:
\end_layout

\begin_layout Standard
Java EE è un ambiente runtime per le applicazioni Java che fornisce un insieme
 completo di servizi e funzionalità per lo sviluppo di applicazioni distribuite,
 come ad esempio servlet, JSP, EJB, JPA, JMS e altri.
 Java EE fornisce un ambiente di esecuzione standardizzato per le applicazioni
 Java, che garantisce che le applicazioni possano essere eseguite su più
 piattaforme hardware e software in modo affidabile e scalabile.
\end_layout

\begin_layout Standard
Microsoft .NET è un ambiente runtime per le applicazioni basate su Windows
 che fornisce un insieme completo di servizi e funzionalità per lo sviluppo
 di applicazioni desktop, web e mobile.
\end_layout

\end_deeper
\begin_layout Standard
La piattaforma si occupa, in modo trasparente, della definizione e della
 gestione dell’ambiente di esecuzione per l’applicazione, e quindi potrebbe
 non essere necessario occuparsene direttamente.
\end_layout

\begin_layout Standard
Una piattaforma può semplificare lo sviluppo e l’esecuzione delle applicazioni
 – ma le applicazioni devono avere l’architettura richiesta dalla piattaforma.
\end_layout

\begin_layout Standard
Alcune piattaforme moderne (come quelle per il cloud) consentono di rilasciare
 ed eseguire le applicazioni in un cluster di computer.
 Alcune piattaforme consentono anche di rilasciare ed eseguire un’applicazione,
 in modo flessibile, sia in un cloud pubblico che in un proprio data center
 privato.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Macchine virtuali e virtualizzazione di sistema
\end_layout

\begin_layout Section
Cloud Computing
\end_layout

\begin_layout Standard
Il cloud computing ha l’obiettivo di fornire il computing (risorse computazional
i) come un servizio di utilità.
\end_layout

\begin_layout Standard
Oggi è sempre più comune rilasciare i propri sistemi software nel cloud
 – o in data center gestiti come cloud privati.
\end_layout

\begin_layout Standard
Il cloud computing è un modello di elaborazione che abilita: 
\end_layout

\begin_layout Itemize
un accesso in rete, su richiesta, ubiquo e conveniente.
\end_layout

\begin_layout Itemize
un pool di risorse di calcolo (CPU, storage, reti, sistemi operativi, servizi
 e/o applicazioni) condivise e configurabili.
\end_layout

\begin_deeper
\begin_layout Standard
le risorse di calcolo possono essere acquisite e rilasciate rapidamente
 e in modo dinamico con uno sforzo di gestione minimo, o comunque con un’interaz
ione minima con il fornitore del servizio.
\end_layout

\end_deeper
\begin_layout Standard
Tre modelli di servizio principali offerti dal cloud computing:
\end_layout

\begin_layout Itemize

\series bold
Software as a Service
\series default
 – SaaS.
 Il servizio è un’applicazione in esecuzione nel cloud – il consumatore
 è un utente finale dell’applicazione – il fornitore è chi l’ha realizzata.
\end_layout

\begin_layout Itemize

\series bold
Platform as a Service 
\series default
– PaaS.
 Il servizio è una piattaforma – il consumatore è uno sviluppatore di applicazio
ni per la piattaforma – il fornitore è chi gestisce la piattaforma.
\end_layout

\begin_layout Itemize

\series bold
Infrastructure as a Service
\series default
 – IaaS il servizio è relativo a risorse computazionali infrastrutturali
 virtuali (CPU e sistemi operativi, storage e connettività)– il consumatore
 è un operatore (Ops) per un ambiente virtuale – il fornitore è chi gestisce
 l’infrastruttura
\end_layout

\begin_layout Standard
Le risorse di calcolo offerte nel cloud computing risiedono fisicamente
 nelle infrastrutture di cloud computing, gestite da fornitori di servizi
 cloud.
\end_layout

\begin_layout Standard
Un’infrastruttura di cloud computing (o semplicemente cloud) comprende l’insieme
 degli elementi hardware e software necessari per abilitare il cloud computing.
\end_layout

\begin_layout Standard
Si può immaginare facilmente che l'insieme di elementi necessari possano
 essere: server, storage, reti, software di virtualizzazione, di gestione
 e di automazione degli ambienti, un’interfaccia di programmazione (tramite
 cui gli utenti possono accedere alle risorse di calcolo e ai servizi di
 cloud computing).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 12.30.13.png
	lyxscale 10
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
IaaS, PaaS, SaaS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 12.36.22.png
	lyxscale 10
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
I diversi modelli di servizio sono caratterizzati da differenti livelli
 di flessibilità e ottimizzazione.
 Infatti i servizi SaaS sono i meno flessibili ma possono essere ottimizzati
 , gli IaaS i più flessibili ma possono essere meno ottimizzati, mentre
 i PaaS offrono un livello intermedio perché le applicazioni che si possono
 realizzare sono indipendenti dal dominio applicativo ma vincolate dalla
 piattaforma.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il cloud computing prevede quattro modelli di deployment:
\end_layout

\begin_layout Itemize

\series bold
public cloud 
\series default
l’infrastruttura di cloud computing è resa disponibile al pubblico.
\end_layout

\begin_layout Itemize

\series bold
private cloud
\series default
 l’infrastruttura di cloud è gestita per una singola organizzazione.
\end_layout

\begin_layout Itemize

\series bold
hybrid cloud
\series default
 l’infrastruttura di cloud è la composizione di due o più cloud.
\end_layout

\begin_layout Itemize

\series bold
community cloud
\series default
 l’infrastruttura di cloud è condivisa da più organizzazioni.
\end_layout

\begin_layout Subsection*
Il termine servizio
\end_layout

\begin_layout Standard
Nel cloud un servizio è una ben precisa entità computazionale, è gestito
 da un’organizzazione (il fornitore del servizio), può essere acceduto mediante
 Internet da un client che è l’utente (o consumatore) del servizio ed è
 incapsulato, ossia ha un’interfaccia definita contrattualmente, e la sua
 implementazione è trasparente agli utenti.
\end_layout

\begin_layout Subsection*
Caratteristiche essenziali per il cloud computing
\end_layout

\begin_layout Enumerate
servizi su richiesta: un consumatore può acquisire risorse di calcolo in
 modo unilaterale e automatico.
\end_layout

\begin_layout Enumerate
accesso in rete: le risorse di calcolo sono accessibili in Internet.
\end_layout

\begin_layout Enumerate
pooling di risorse: le risorse di calcolo di un fornitore sono riunite per
 servire molti consumatori, secondo un modello multi-tenant.
\end_layout

\begin_layout Enumerate
elasticità rapida: le risorse di calcolo possono essere ottenute (e poi
 rilasciate) in modo rapido ed elastico.
\end_layout

\begin_layout Enumerate
misura dei servizi: l’uso delle risorse è controllato in modo automatico,
 sulla base di misure appropriate
\end_layout

\begin_layout Subsection*
Attori in gioco
\end_layout

\begin_layout Standard
Un’organizzazione o una persona può svolgere uno (o più) dei seguenti ruoli
 :
\end_layout

\begin_layout Itemize
cloud provider – fornitore di utility computing (IaaS o PaaS)
\end_layout

\begin_layout Itemize
cloud user – utente (consumatore) di utility computing (IaaS o PaaS)
\end_layout

\begin_layout Itemize
SaaS provider – fornitore di un’applicazione SaaS un SaaS provider potrebbe
 anche essere un cloud user 
\end_layout

\begin_layout Itemize
SaaS user – utente (consumatore) di un’applicazione SaaS
\end_layout

\begin_layout Standard
Come esempio, consideriamo Mario Rossi (SaaS user), che è un client del
 servizio Netflix – il quale è realizzato dalla Netflix Incorporation (SaaS
 provider, Cloud User)e rilasciato nel cloud di Amazon (Cloud Provider).
\end_layout

\begin_layout Subsection*
Architettura del cloud
\end_layout

\begin_layout Standard
Un’infrastruttura di cloud computing (o semplicemente cloud) è l’insieme
 degli elementi hardware e software necessari per abilitare il cloud computing.
\end_layout

\begin_layout Standard
Un insieme di strumenti software:
\end_layout

\begin_layout Itemize
un software di virtualizzazione – per trasformare le risorse fisiche in
 risorse computazionali virtuali 
\end_layout

\begin_layout Itemize
un insieme di strumenti software di gestione e di automazione degli ambienti
 e delle risorse 
\end_layout

\begin_layout Itemize
eventuale software di piattaforma e software applicativo
\end_layout

\begin_layout Itemize
un’interfaccia di programmazione (API) – che consente agli utenti di accedere
 alle risorse virtualizzate e ai servizi di cloud computing – mediante un’interf
accia web, REST e/o CLI
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 13.02.51.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Qui sono menzionate le dierse tecnologie che vengono utilizzate nel cloud,
 e a quale strato appartengono, se infrastrutturale, di piattaforma, o software.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Esempi di servizi nel cloud 
\end_layout

\begin_layout Subsection*
Google Workspace (SaaS)
\end_layout

\begin_layout Standard
Fornisce un insieme di strumenti di produttività e di collaborazione, comprende
 applicazioni come Gmail, Drive, Meet, Calendar.
\end_layout

\begin_layout Standard
Queste applicazioni sono eseguite nel cloud di Google, che è l'infrastruttura
 cloud che Google utilizza per fornire agli utenti finali i propri prodotti.
\end_layout

\begin_layout Subsection*
Google App Engine (PaaS)
\end_layout

\begin_layout Standard
Consente di creare ed eseguire applicazioni web scalabili sulla piattaforma
 Google App engine.
\end_layout

\begin_layout Standard
Le applicazioni possono essere create usando una varietà di linguaggi, librerie,
 framework.
 L'utente deve predisporre il codice e configurare l'applicazione che poi
 verrà eseguita nel cloud di Google Cloud.Alcune caratteristiche sono: 1.
 scalabilità e bilanciamento del carico automatici 2.
 autenticazione e sicurezza 3.
 amministrazione semplificata 4.
 inizialmente gratuito – poi paghi solo quello che usi.
\end_layout

\begin_layout Subsection*
Amazon Web Services (IaaS e PaaS)
\end_layout

\begin_layout Standard
AWS offre servizi di elaborazione, storage di database, distribuzione di
 contenuti e altre funzionalità, ideali per aiutare a creare applicazioni
 in modo flessibile, scalabile e affidabile.
\end_layout

\begin_layout Standard
Permette di realizzare qualunque applicazione – indipendentemente dal dominio
 di business.
\end_layout

\begin_layout Standard
Alcuni servizi infrastrutturali (IaaS):
\end_layout

\begin_layout Itemize
risorse di calcolo – 
\series bold
Amazon EC2 
\series default
(macchine virtuali), Elastic Container Service e Kubernetes Service (container)
 
\end_layout

\begin_layout Itemize
storage – 
\series bold
Amazon S3 e EBS 
\end_layout

\begin_layout Itemize
basi di dati –
\series bold
 Amazon RDS e DynamoDB
\end_layout

\begin_layout Itemize
reti – Amazon Virtual Private Cloud e Elastic Load Balancing
\end_layout

\begin_layout Standard
I servizi infrastrutturali di AWS possono essere utilizzati in modo integrato
 per realizzare ambienti di esecuzione, anche complessi, in cui rilasciare
 le proprie applicazioni.
 Il provisioning di queste risorse di calcolo può essere effettuato in modo
 interattivo, mediante un’interfaccia web oppure in modo automatizzato,
 mediante l’uso di script e di ulteriori servizi AWS di supporto al rilascio
 del software – o anche mediante l’uso di strumenti di terze parti.
\end_layout

\begin_layout Standard
Alcuni servizi di piattaforma (PaaS) e servizi applicativi:
\end_layout

\begin_layout Itemize
applicazioni web scalabili – 
\series bold
AWS Elastic Beanstalk
\series default
 e 
\series bold
Lambda
\series default
 (serverless) 
\end_layout

\begin_layout Itemize
risorse di calcolo - 
\series bold
AWS Elastic COntainer Service ECS 
\series default
e Kubernetes
\end_layout

\begin_layout Itemize
messaging e publish-subscribe – Amazon SQS e SNS 
\end_layout

\begin_layout Itemize
per sviluppatori (Dev) e operatori (Ops) – AWS CodeCommit, CodeDeploy e
 CodePipeline
\end_layout

\begin_layout Standard
I servizi di piattaforma di AWS consentono lo sviluppo e il rilascio di
 applicazioni basate su un’architettura software standardizzata in ambienti
 di esecuzione standardizzati (predefiniti) scalabili.
 Quando viene rilasciata un’applicazione in un servizio PaaS, viene creato
 (automaticamente e in modo trasparente, e poi fatto evolvere) un ambiente
 di esecuzione per l’applicazione – realizzato come un insieme di risorse
 IaaS .
\end_layout

\begin_layout Subsection*

\series bold
Amazon EC2
\end_layout

\begin_layout Standard
Amazon EC2 fornisce capacità di calcolo (ovvero macchine virtuali) nel cloud.
\end_layout

\begin_layout Standard
I nodi di calcolo virtuali si chiamano AMI Amazon Machine Instance.
\end_layout

\begin_layout Itemize
diversi tipi di AMI predefinite – da 1 a 96 vCPU a 64 bit (Intel Xeon),
 da 0.5GB a 192 GB RAM, storage EBS (HD o SSD, fino a 8x1.9TB SSD) – e anche
 istanze Bare Metal.
\end_layout

\begin_layout Itemize
le AMI possono essere preconfigurate con una varietà di sistemi operativi
 (ad es., Linux o Windows) e di software.
\end_layout

\begin_layout Subsection*

\series bold
Amazon S3 e EBS 
\end_layout

\begin_layout Standard
Amazon Simple Storage Service (S3) fornisce storage di file nel cloud con
 una semplice interfaccia web (REST o SOAP).
 Può essere utilizzato come meccanismo di storage per EC2.
\end_layout

\begin_layout Standard
Amazon Elastic Block Storage (EBS) è un meccanismo di storage per istanze
 EC2.
\end_layout

\begin_layout Standard
Un’istanza EBS è un volume – composto da blocchi – che può essere montato
 su un’istanza EC2.
 Supporto per diverse qualità: 1.
 diversi livelli per prestazioni e affidabilità 2.
 selezione della zona in cui è allocata l’istanza.
\end_layout

\begin_layout Subsection*

\series bold
Amazon RDS e DynamoDB
\end_layout

\begin_layout Standard
RDS: è un servizio per la gestione di database relazionali nel cloud consente
 l’accesso, con tutte le funzionalità, a database relazionali come MySQL,
 Oracle, PostgreSQL o Amazon Aurora.
\end_layout

\begin_layout Standard
DynamoDB è un datastore NoSQL, ovvvero un sistema di gestione di database
 non relazionali.
\end_layout

\begin_layout Subsection*

\series bold
AWS Elastic Beanstalk
\series default
 
\end_layout

\begin_layout Standard
AWS Elastic Beanstalk è una piattaforma scalabile per applicazioni web che
 fornisce un modo ancora più semplice (rispetto a IaaS) per rilasciare e
 gestire applicazioni nel cloud di AWS.
\end_layout

\begin_layout Standard
Caricando semplicemente il proprio codice, Elastic Beanstalk gestisce automatica
mente l’implementazione, da provisioning di capacità e auto scaling al monitorag
gio della salute dell'applicazione.
\end_layout

\begin_layout Subsection*

\series bold
AWS Lambda
\end_layout

\begin_layout Standard
Un servizio di elaborazione serverless (“senza server”) – ovvero, “completamente
 gestito”.
 AWS Lambda è un servizio di elaborazione serverless che ti permette di
 eseguire il codice senza effettuare il provisioning o gestire i server.
 Con Lambda, è possibile eseguire codice per qualsiasi tipo di applicazione
 o servizio di back-end, è possibile scrivere le funzioni Lambda nel linguaggio
 che si preferisce.
 
\end_layout

\begin_layout Subsection*

\series bold
AWS Elastic Container Service ECS 
\end_layout

\begin_layout Standard
AWS Elastic Container Service ECS
\series bold
 
\series default
è un servizio altamente scalabile per la gestione di container.
 
\end_layout

\begin_layout Standard
Amazon ECS è un servizio di orchestrazione dei container completamente gestito,
 consente di eseguire, in modo semplice, applicazioni a container in un
 cluster – gestito mediante un insieme di nodi Amazon EC2.
\end_layout

\begin_layout Standard
Un servizio (in parte di piattaforma, in parte infrastrutturale) che evita
 di dover gestire (installare e dimensionare) un’infrastruttura per la gestione
 di un cluster per container.
\end_layout

\begin_layout Subsection*
AWS e DevOps
\end_layout

\begin_layout Standard
AWS fornisce anche un insieme di servizi per creare e rilasciare il software
 in modo rapido e affidabile nel cloud AWS tramite pratiche DevOps – ad
 esempio: 1.
 provisioning e gestione dell’infrastruttura 2.
 gestione del codice delle applicazioni 3.
 automatizzazione del rilascio del software 4.
 monitoraggio.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 12.13.47.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Le istanze di risorse richieste da un utente di servizi IaaS e PaaS possono
 essere allocate in una o più zone (una porzione di una regione), in una
 o più regioni (luogo geografico in cui sono raggruppati i data center).
 In questa figura l'applicazione A è rilasciata in una singola 
\series bold
zona di disponibilità
\series default
 in una sola 
\series bold
regione, 
\series default
B in più zone ed in una sola regione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Conclusioni
\end_layout

\begin_layout Standard
un semplice servizio di tipo IaaS per macchine virtuali – che consente di
 scegliere:
\end_layout

\begin_layout Itemize
numero di vCPU, quantità di memoria e OS da installare.
\end_layout

\begin_layout Itemize
eventuali applicazioni pre-installate sulla VM – da un elenco predefinito
 – ad es., Tomcat.
\end_layout

\begin_layout Standard
un semplice servizio di tipo PaaS (scalabile, ma senza elasticità) per applicazi
oni web basate su Tomcat – che consente di scegliere:
\end_layout

\begin_layout Itemize
l’unità di rilascio – per semplicità, un singolo file war.
\end_layout

\begin_layout Itemize
il numero di server Tomcat in cui eseguire l’applicazione.
\end_layout

\begin_layout Section
Continuous Delivery
\end_layout

\begin_layout Standard
La Continuous Delivery è la principale pratica tecnica DevOps, per effettuare
 la delivery del software in modo automatizzato.
 Racchiude un insieme di principi e pratiche per ridurre costi, tempi e
 rischi del rilascio di versioni incrementali del software ai suoi utenti.
\end_layout

\begin_layout Standard
La Continuous Delivery di concentra dal momento in cui viene effettuato
 il commit di un cambiamento nel software a quando gli utenti possono effettivam
ente utilizzare il software modificato.
\end_layout

\begin_layout Standard
Gli obiettivi complessivi sono:
\end_layout

\begin_layout Itemize

\series bold
fare in modo che il sistema software possa essere rilasciato nell’ambiente
 di produzione in ogni momento – ovvero, in modo “continuo”.
\end_layout

\begin_layout Itemize
aumentare il valore di business del software.
\end_layout

\begin_layout Itemize
ridurre i rischi associati ai rilasci.
\end_layout

\begin_layout Subsection*
I termini delivery, deployment, release
\end_layout

\begin_layout Itemize

\series bold
Una delivery è un rilascio nell’ambiente di produzione
\series default
 – che talvolta viene chiamato un “deployment”
\end_layout

\begin_layout Itemize

\series bold
Un deployment è l’installazione del software in un ambiente di esecuzione
\series default
 – che talvolta viene chiamata una “delivery”
\end_layout

\begin_layout Itemize
release è un verbo e indica un’azione – ma talvolta 
\series bold
“release” viene usato (come nome) per indicare una versione di un’applicazione.
 
\series default
La release è l’ultima attività di una delivery – ma talvolta “release” viene
 usato per indicare l’intera “delivery”.
\end_layout

\begin_layout Subsection*
Deployment Pipeline
\end_layout

\begin_layout Standard
Una Deployment Pipeline consiste di una sequenza di passi (o fasi) da svolgere
 tra il commit di un cambiamento del software e il rilascio della nuova
 versione del sistema software.
 Ha lo scopo di automatizzare l’intero processo di delivery.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 13.27.42.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Un esempio di deployment pipeline.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funzionamento della deployment pipeline:
\end_layout

\begin_layout Enumerate
ogni commit di un cambiamento del codice avvia una nuova istanza della pipeline.
\end_layout

\begin_layout Enumerate
le fasi della pipeline vengono svolte una alla volta e in sequenza.
 Il successo di una fase abilita l’esecuzione della fase successiva, il
 fallimento di una fase causa invece l’interruzione dell’istanza della pipeline.
\end_layout

\begin_layout Enumerate
il completamento di tutti le fasi dell’istanza può portare al rilascio della
 nuova versione del software nell’ambiente di produzione.
\end_layout

\begin_layout Enumerate
la pipeline può essere attivata più volte – ogni volta dà luogo a una nuova
 istanza della pipeline.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 13.27.59.png
	lyxscale 10
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Funzionamento della deployment pipeline.
 
\series bold
Uno sviluppatore modifica il codice sorgente nel proprio ambiente locale
 di sviluppo (un computer che ha un IDE e un SDK).

\series default
 In sintesi, un IDE è un ambiente di sviluppo completo che aiuta a scrivere
 codice, include un editor di codice, un compilatore, un debugger, mentre
 un SDK fornisce le risorse necessarie per sviluppare app per una specifica
 piattaforma, include un insieme di librerie, strumenti e documentazione.
 
\series bold
Quando lo sviluppatore pensa di aver concluso la modifica effettua il commit.
 Uno strumento software di continuous delivery avvia automaticamente una
 nuova istanza della deployment pipeline.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Build
\end_layout

\begin_layout Standard
L'ambiente utilizzato per eseguire la build è un server di integrazione,.
\end_layout

\begin_layout Enumerate
compilazione e assemblaggio del software – in un formato “binario” ed “eseguibil
e”, adatto alla distribuzione e all’installazione.
\end_layout

\begin_layout Enumerate
esecuzione di un ampio insieme di test – test unitari e test di integrazione.
\end_layout

\begin_layout Enumerate
analisi statica del codice – per fornire un feedback sulla bontà del codice.
\end_layout

\begin_layout Enumerate
gli elaborati prodotti vengono salvati in un repository condiviso – per
 poter essere utilizzati nelle fasi successive della pipeline.
\end_layout

\begin_layout Subsection*
Test automatizzati
\end_layout

\begin_layout Standard
Vengono poi eseguiti dei test end-to-end e di accettazione automatizzati,
 che operano sull’intero sistema, per verificare il software in modo completo.
 Questi test vengono eseguiti in uno o più ambienti di test (preliminarmente,
 è richiesta la preparazione di ciascun ambiente di test e il deployment
 del software in quell’ambiente).
\end_layout

\begin_layout Standard
I test (funzionali e di qualità) possono essere suddivisi su più passi successiv
i della pipeline.
\end_layout

\begin_layout Standard
Ogni ulteriore passo effettua dei test via via più accurati – può richiedere
 un ambiente di test sempre più simile all’ambiente di produzione – e di
 solito richiede un tempo sempre maggiore.
\end_layout

\begin_layout Standard
Talvolta sono necessari anche dei test di accettazione manuali – per verificare
 ciò che non è stato o non può essere verificato in modo automatizzato
\end_layout

\begin_layout Subsection*
Release
\end_layout

\begin_layout Standard
La fase di release ha lo scopo di rilasciare il sistema agli utenti finali,
 nell’ambiente di produzione.
\end_layout

\begin_layout Standard
Non è solo deployment – si conclude quando le richieste degli utenti vengono
 effettivamente indirizzate alla nuova versione del software.
\end_layout

\begin_layout Standard
Anche la release viene eseguita automaticamente – ma in genere deve essere
 avviata “manualmente” da un operatore umano.
\end_layout

\begin_layout Standard
È l’attività più rischiosa della pipeline, le fasi precedenti della deployment
 pipeline hanno proprio l’obiettivo di minimizzare questi rischi.
\end_layout

\begin_layout Subsection*
Riassumendo
\end_layout

\begin_layout Standard
I diversi passi della pipeline vengono svolti in ambienti differenti.
 Gli sviluppatori operano sui loro computer, la build viene di solito eseguita
 in un server di integrazione, la verifica viene effettuata in uno o più
 ambienti di test,il rilascio finale avviene nell’ambiente di produzione.
\end_layout

\begin_layout Standard
La deployment pipeline si deve occupare anche della preparazione degli ambienti
 di test e di produzione – e non solo del deployment in questi ambienti.
\end_layout

\begin_layout Subsection*
Il termine 
\begin_inset Quotes eld
\end_inset

continuous
\begin_inset Quotes erd
\end_inset

 in continuous delivery
\end_layout

\begin_layout Standard
La parola continuous (continuo, ininterrotto) suggerisce che la deployment
 pipeline vada avviata spesso – anche più volte al giorno.
\end_layout

\begin_layout Standard
Non è il rilascio che è continuo, ma la “prontezza al rilascio”.
\end_layout

\begin_layout Standard
Le attività della delivery (build, costruzione degli ambienti, deployment
 e test) vengono eseguite frequentemente in questo modo, viene verificato
 in modo continuo che il sistema software sia “pronto per il rilascio”.
\end_layout

\begin_layout Subsection*
Principi della delivery del software
\end_layout

\begin_layout Itemize
Automatizzare quasi tutto – sia le singole attività che l’intera deployment
 pipeline.
\end_layout

\begin_layout Itemize
se è rischioso e può far male, allora fallo più spesso\SpecialChar endofsentence

\end_layout

\begin_layout Itemize
tenere tutto sotto controllo di versione.
\end_layout

\begin_layout Itemize
costruisci la qualità dentro al sistema e al processo – non pensare di poterla
 verificare dopo.
\end_layout

\begin_layout Itemize
“done” (un termine di Scrum) significa “potenzialmente rilasciabile” (o
 rilasciato).
\end_layout

\begin_layout Itemize
responsabilizza le persone.
\end_layout

\begin_layout Itemize
persegui un miglioramento continuo.
\end_layout

\begin_layout Subsection*
Obiettivi della Deployment Pipeline
\end_layout

\begin_layout Itemize
Abilitare il rilascio automatizzato, ripetibile e affidabile del software.
 Per poter eseguire, su richiesta, il deployment di ogni versione del software
 in ogni ambiente semplicemente premendo un pulsante.
\end_layout

\begin_layout Itemize
Fornire feedback utile per identificare e risolvere problemi, nel modo più
 rapido possibile.
\end_layout

\begin_layout Itemize
Sostenere una collaborazione stretta e proficua tra tutte le persone coinvolte
 nel rilascio del software.
\end_layout

\begin_layout Itemize
Rendere visibili le attività legate al rilascio del software.
\end_layout

\begin_layout Subsection*
Vantaggi
\end_layout

\begin_layout Standard
Benefici sostenuti dalla deployment pipeline:
\end_layout

\begin_layout Itemize
l’automazione delle attività sostiene la ripetibilità del delivery.
\end_layout

\begin_layout Itemize
rilasci frequenti e riduzione del rischio.
\end_layout

\begin_layout Itemize
maggiore affidabilità dei rilasci e riduzione degli errori.
\end_layout

\begin_layout Itemize
flessibilità dei rilasci.
\end_layout

\begin_layout Itemize
i team sono più autonomi e più responsabili.
\end_layout

\begin_layout Itemize
miglioramento continuo del processo di delivery e dei cicli di (sviluppo
 e) rilascio del software.
\end_layout

\begin_layout Itemize
riduzione dello stress.
\end_layout

\begin_layout Subsection*
Strategie e tecniche per il deployment e il rilascio (lato server) di una
 nuova versione di un’applicazione o di un servizio software.
\end_layout

\begin_layout Standard
Vengono discusse alcune tecniche per il rilascio senza interruzione di servizio
 (zero-downtime release) – in cui la transizione da una versione del software
 alla successiva avviene, per gli utenti, in modo istantaneo.Queste tecniche
 supportano anche il ripristino (rollback) di una versione precedente del
 software, si basano in genere su un disaccoppiamento del deployment dalla
 release.
\end_layout

\begin_layout Subsection*
Blue-green deployment
\end_layout

\begin_layout Standard
Ci sono due versioni dell’ambiente di produzione – “blu” e “verde” – i cui
 nodi ospitano l’applicazione o il servizio da aggiornare:
\end_layout

\begin_layout Itemize
la versione corrente A è in esecuzione nell’ambiente verde 
\end_layout

\begin_layout Itemize
la nuova versione B viene installata nell’ambiente blu
\end_layout

\begin_layout Standard
Quando il deployment di B è completato, i client vengono indirizzati verso
 l’ambiente blu.
\end_layout

\begin_layout Standard
Questa può essere considerata una strategia di rilascio senza interruzione
 di servizio perché la transazione dalla versione A alla B richiede solo
 il tempo di reindirizzamento del traffico del client, che in genere è molto
 veloce.
\end_layout

\begin_layout Standard
Dopo la realase, se non ci sono problemi, viene deallocato il precidente
 ambiente verde liberando le sue risorse.
\end_layout

\begin_layout Standard
L'inconvente principale è che durante la transizione è richiesto un numero
 di nodi doppio rispetto a quelli utilizzati a regime.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 15.34.03.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Blue-green deployment
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Canary releasing
\end_layout

\begin_layout Standard
È uno stile di deployment e release utile quando la versione corrente A
 del software è eseguita (in modo replicato) su più nodi.
\end_layout

\begin_layout Standard
La nuova versione B del software viene installata solo su alcuni di questi
 nodi (o su dei nuovi nodi).
\end_layout

\begin_layout Standard
Inizialmente, solo le richieste di alcuni utenti vengono reindirizzate verso
 questa nuova versione se non ci sono problemi, il rilascio prosegue anche
 sugli altri nodi.
 In questo modo è possibile scoprire rapidamente degli eventuali problemi
 legati alla nuova versione senza che ci sia impatto sulla maggior parte
 degli utenti.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 15.42.34.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Canary releasing
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
A/B testing
\end_layout

\begin_layout Standard
Ha l’obiettivo di effettuare un esperimento, nell’ambiente di produzione,
 per mettere a confronto due versioni (A e B) di un’applicazione o di un
 servizio software, ad esempio per apprendere le preferenze degli utenti
 tra A e B.
\end_layout

\begin_layout Standard
A è la versione corrente, e la versione B viene di solito sperimentata solo
 su un sottoinsieme degli utenti, per un breve periodo di tempo.
\end_layout

\begin_layout Standard
Il monitoraggio degli utenti consente di confrontare il loro comportamento
 rispetto alle due versioni.
 Questa tecnica è supportata dal canary releasing.
\end_layout

\begin_layout Subsection*
Rollback
\end_layout

\begin_layout Standard
Se vengono rilevati problemi nel rilascio, allora è necessario effettuare
 un rollback (ripristino) della versione precedentemente funzionante dell’applic
azione o del servizio .
\end_layout

\begin_layout Standard
Il modo in cui può essere effettuato dipende dalla strategia usata per il
 rilascio – ad es.
 con blue-green deployment gli utenti vengono reindirizzatti alla versione
 verde, con canary releasing la versione precedente va ripristinata nei
 server (di solito pochi) in cui era stata rilasciata la nuova versione.
 In alternativa, viene ripetuto il rilascio della versione precedente del
 software (creando una nuova istanza della deployment pipeline ?).
\end_layout

\begin_layout Subsection*
Rolling upgrade
\end_layout

\begin_layout Standard
Consiste nell’installare la nuova versione B dell’applicazione o servizio
 software in un piccolo numero di nodi alla volta – e nel frattempo disattivare
 uno stesso numero di nodi in cui è installata la versione attuale A.
\end_layout

\begin_layout Standard
Rispetto al blue green deployment questa tecnica ha il vantaggio di richiedere
 un numero complessivo minore di server che devono essere attivi contemporaneame
nte.
\end_layout

\begin_layout Standard
Tuttavia, presenta l’inconveniente di una possibile 
\series bold
“inconsistenza” delle versioni
\series default
 – perché, durante l’upgrade, ci sono nodi che forniscono la versione A
 e nodi che forniscono la versione B del software.
 Questo problema è presente anche un canary releasing.
\end_layout

\begin_layout Subsection*
Feature toggling
\end_layout

\begin_layout Standard
Il feature toggling consiste nello sviluppare e rilasciare un'applicazione
 o un servizio software che contiene al suo interno delle funzionalità (feature)
 aggiuntive oppure implementate in più varianti o versioni che possono essere
 attivate o disattivate mediante dei parametri o flag di configurazione
 (feature toggle).
\end_layout

\begin_layout Standard
La transizione da una versione A ad una versione B 
\series bold
non avviene al momento del deployment – ma la release si conclude quando
 vengono cambiati i parametri di configurazione.
\end_layout

\begin_layout Standard
Consente di evitare inconsistenze tra versioni quando si utilizza il rolling
 upgrade.
\end_layout

\begin_layout Standard
Il feature toggling supporta: 1.
 l’esecuzione di test A/B 2.
 il rollback (senza ripetizione del deployment) 3.
 la tattica della “degradation” (che offre la possibilità di disabilitare
 alcune funzionalità in modo parziale per esempio in caso di problemi di
 disponibilità) 4.
 il “dark launching” (il deployment di alcune caratteristiche che però non
 vengono rese disponibili agli utenti).
\end_layout

\begin_layout Subsection*
Conclusioni
\end_layout

\begin_layout Standard
Gli obiettivi del Continuous Delivery si possono considerare raggiunti quando
 si è in grado di effettuare in modo automatizzato e continuo 1.
 l’integrazione del software realizzato dai team di sviluppo 2.
 la build e il test del software, per rilevare eventuali problemi 3.
 lo spostamento del software verso ambienti di esecuzione sempre più simili
 all’ambiente di produzione finale – per assicurarsi che il software funzioni
 in produzione.
\end_layout

\begin_layout Standard
Questo è possibile sulla base di una deployment pipeline, che permette l’automat
izzazione di tutte le attività della delivery del software.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Screen Shot 2023-02-14 at 16.21.34.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Continuous Delivery
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Container e virtualizzazione basata su container
\end_layout

\begin_layout Section
Orchestrazione di container
\end_layout

\end_body
\end_document
